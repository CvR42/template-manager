.. Tm - an interface code generator.
.. Author: C. van Reeuwijk.
..
.. All rights reserved.
..
.. file: cllu.ht
.. Tm C support. Variant: linked lists, union constructors.
/*** WARNING: THIS IS GENERATED CODE. ***/

/* ---- start of ${tplfilename} ---- */
/* External definitions (Version for linked list).

   template file:      ${tplfilename}
   datastructure file: ${dsfilename}
   tm version:         $(tmvers)
   tm kernel version:  $(kernel-version)
 */

/* data structures */

/* forward reference typedefs for all types.
 * C does not like the use of undefined types, but does not
 * mind the use of pointers to (yet) undefined types.
 */
.foreach t $(need_ds_list)
typedef struct str_${stemname $t} *$t_list;
.endforeach
.foreach t ${depsort $(need_ds)}
typedef struct str_$t *$t;
.endforeach

.foreach t $(need_ds)
#define $tNIL ($t)0
.endforeach
.foreach t $(need_ds_list)
#define $t_listNIL ($t_list)0
.endforeach

.foreach t ${comm $(need_ds) "" ${ctypelist}}
.foreach c ${conslist $t}
#define to_$c(e) (&(e)->u.ue_$c)
.endforeach
.endforeach

.foreach t ${comm $(need_ds) "" ${ctypelist}}
.if ${len ${conslist $t}}
typedef enum en_tags_$t {
    ${seplist ", " ${prefix TAG ${conslist $t}}}
} tags_$t;
.else
typedef int tags_$t;
.endif

.endforeach

.foreach t ${depsort $(need_ds)}
.. Structure definitions for all the constructors of the type
.. That have elements (C does not like empty structures or unions).
.if ${member $t ${ctypelist}}
.. Constructor type
.. Generate structure definitions for all constructors with
.. fields.
.. Also set 'makeunion' if at least one such structure is
.. generated, because otherwise no union must be generated for
.. the structure of the entire type.
.set makeunion 0
.foreach c ${conslist $t}
.. Constructors with 0 elements do not have a structure..
.if ${len ${allfields $c}}
.set makeunion 1
/* Structure for constructor $c */
typedef struct str_$c {
.foreach e ${allfields $c}
    ${type $c $e} $e;
.endforeach
} C_$c;
.else
/* Constructor $t has no fields */
.endif

.endforeach
/* Constructor type $t */
struct str_$t {
    tags_$t tag;
.if $(makeunion)
    union uni_$t {
.foreach c ${conslist $t}
.. Constructors with 0 elements do not have a structure..
.if ${len ${allfields $c}}
	C_$c ue_$c;
.endif
.endforeach
    } u;
.endif
.. Generate 'next' pointers for all necessary list levels
.set links ${filt $t(*) next\1 $(need_ds_list)}
.foreach link $(links)
    ${subs next(*) $t\1 $(link)}_list $(link);
.endforeach
#ifdef LOGNEW
    long int lognew_id;
#endif
};

.endif
.if ${member $t ${tuplelist} ${classlist}}
struct str_$t {
.foreach e ${allfields $t}
    ${type $t $e} $e;
.endforeach
.if ${not ${len ${allfields $t}}}
    int _dummy_field;
.endif
.. Generate 'next' pointers for all necessary list levels
.set links ${filt $t(*) next\1 $(need_ds_list)}
.foreach link $(links)
    ${subs next(*) $t\1 $(link)}_list $(link);
.endforeach
#ifdef LOGNEW
    long int lognew_id;
#endif
};

.endif
.endforeach
.foreach t $(need_ds_list)
#define $t_listNIL ($t_list)0
.endforeach

#ifdef LOGNEW
.foreach t $(want_new)
.if ${member $t ${tuplelist} ${classlist}}
#define new_$t(${seplist , ${allfields $t}}) real_new_$t(${seplist , ${allfields $t} __FILE__ __LINE__})
.else
.foreach c ${conslist $t}
#define new_$c(${seplist , ${allfields $c}}) real_new_$c(${seplist , ${allfields $c} __FILE__ __LINE__})
.endforeach
.endif
.endforeach
..
.. slice_<type>() routines
.foreach t $(want_slice_list)
#define slice_$t_list(l,b,e) real_slice_$t_list(l,b,e,__FILE__,__LINE__)
.endforeach
..
.. rdup_<type>() routines
.foreach t $(want_rdup)
#define rdup_$t(e) real_rdup_$t(e,__FILE__,__LINE__)
.endforeach
.foreach t $(want_rdup_list)
#define rdup_$t_list(e) real_rdup_$t_list(e,__FILE__,__LINE__)
.endforeach
..
.. fscan_<type>() routines
.foreach t $(want_fscan)
#define fscan_$t(f,e) real_fscan_$t(f,e,__FILE__,__LINE__)
.endforeach
.foreach t $(want_fscan_list)
#define fscan_$t_list(f,l) real_fscan_$t_list(f,l,__FILE__,__LINE__)
.endforeach
#endif

.. new_<cons> and new_<type> routines
.foreach t $(want_new)
.if ${member $t ${tuplelist} ${classlist}}
.set tl
.foreach e ${allfields $t}
.append tl ${type $t $e}
.endforeach
.if ${== ${len $(tl)} 0}
.set tl void
.endif
#ifdef LOGNEW
extern $t real_new_$t( ${seplist ", " $(tl)}, const char *, const int );
#else
extern $t new_$t( ${seplist ", " $(tl)} );
#endif
.else
.foreach c ${conslist $t}
.set tl
.foreach e ${allfields $c}
.append tl ${type $c $e}
.endforeach
.if ${== ${len $(tl)} 0}
.set tl void
.endif
#ifdef LOGNEW
extern $t real_new_$c( ${seplist ", " $(tl)}, const char *, const int );
#else
extern $t new_$c( ${seplist ", " $(tl)} );
#endif
.endforeach
.endif
.endforeach
.foreach t $(want_new_list)
extern $t_list new_$t_list( void );
.endforeach
..
.. setroom_<type>_list functions.
.. For this library they are dummy functions.
.foreach t $(want_setroom_list)
#define setroom_$t_list(l,rm) (l)
.endforeach
..
.. fre_<type> routines
.foreach t $(want_fre)
extern void fre_$t( $t );
.endforeach
.foreach t $(want_fre_list)
extern void fre_$t_list( $t_list );
.endforeach
..
.. rfre_<type> routines
.foreach t $(want_rfre)
extern void rfre_$t( $t );
.endforeach
.foreach t $(want_rfre_list)
extern void rfre_$t_list( $t );
.endforeach
..
.. append_<type>_list routines
.foreach t $(want_append_list)
extern $t_list append_$t_list( $t_list, $t );
.endforeach
..
.. concat_<type>_list routines
.foreach t $(want_concat_list)
extern $t_list concat_$t_list( $t_list, $t_list );
.endforeach
..
.. reverse_<type>_list routines
.foreach t $(want_reverse_list)
extern $t_list reverse_$t_list( $t_list );
.endforeach
..
.. insert_<type>_list() routines.
.foreach t $(want_insert_list)
extern $t_list insert_$t_list( $t_list, const unsigned int, $t  );
.endforeach
..
.. delete_<type>_list() routines.
.foreach t $(want_delete_list)
extern $t_list delete_$t_list( $t_list, const unsigned int );
.endforeach
..
.. extract_<type>_list() routines.
.foreach t $(want_extract_list)
extern $t_list extract_$t_list( $t_list, const unsigned int, $t *, int * );
.endforeach
..
.. slice_<type>_list routines
.foreach t $(want_slice_list)
#ifdef LOGNEW
$t_list real_slice_$t_list( const $t_list, const unsigned int, const unsigned int, const char *, const int );
#else
$t_list slice_$t_list( const $t_list, const unsigned int, const unsigned int );
#endif
.endforeach
..
.. print_<type> routines
.foreach t $(want_print)
extern void print_$t( TMPRINTSTATE *, const $t );
.endforeach
.foreach t $(want_print_list)
extern void print_$t_list( TMPRINTSTATE *, const $t_list );
.endforeach
..
.. fprint_<type>() routines
.foreach t $(want_fprint)
extern void fprint_$t( FILE *, const $t );
.endforeach
.foreach t $(want_fprint_list)
extern void fprint_$t_list( FILE *, const $t_list );
.endforeach
..
.. rdup_<type> routines
#ifdef LOGNEW
.foreach t $(want_rdup)
extern $t real_rdup_$t( const $t, const char *_f, const int _l );
.endforeach
.foreach t $(want_rdup_list)
extern $t_list real_rdup_$t_list( const $t_list, const char *_f, const int _l );
.endforeach
#else
.foreach t $(want_rdup)
extern $t rdup_$t( const $t );
.endforeach
.foreach t $(want_rdup_list)
extern $t_list rdup_$t_list( const $t_list );
.endforeach
#endif
..
.. fscan_<type>() routines
#ifdef LOGNEW
.foreach t $(want_fscan)
extern int real_fscan_$t( FILE *, $t *, const char *, const int );
.endforeach
.foreach t $(want_fscan_list)
extern int real_fscan_$t_list( FILE *, $t_list *, const char *, const int );
.endforeach
#else
.foreach t $(want_fscan)
extern int fscan_$t( FILE *, $t * );
.endforeach
.foreach t $(want_fscan_list)
extern int fscan_$t_list( FILE *, $t_list * );
.endforeach
#endif
..
.. cmp_<type>() routines
.foreach t $(want_cmp)
extern int cmp_$t( const $t, const $t );
.endforeach
.foreach t $(want_cmp_list)
extern int cmp_$t_list( const $t_list, const $t_list );
.endforeach
..
.. Misc. functions.
.if ${member flush_$(basename) $(want_misc)}
#define flush_$(basename)()
.endif
.if ${member stat_$(basename) $(want_misc)}
extern void stat_$(basename)( FILE * );
.endif
.if ${member get_balance_$(basename) $(want_misc)}
extern int get_balance_$(basename)( void );
.endif
..
/* ---- end of ${tplfilename} ---- */
/* Code generation required ${processortime} milliseconds. */
