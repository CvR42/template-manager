\chapter{The data structure description}
\label{s.ds}
\section{The data structure description}
The data structure description and representation are based on the algebraic
data type of {\Miranda}, see \cite{c.mira} and \cite{c.miraover}.
The exact syntax of the data structure description is given in
appendix~\ref{s.dsgram},
in this section only an informal description is given.
\par
As an example consider the data structure description
\par
\begin{listing}
\verbatiminput{plot.ds}
\end{listing}
\label{plotds}
\par
This description states that the type {\tt plot} has two possible
sets of fields: one set is identified by the \dfn{constructor}:
{\tt XYPlot}; the other set is identified by the constructor {\tt YPlot}.
Type {\tt plot} is called a \dfn{constructor type}.
The constructor is used to identify the actual set that occurs in an 
instance of a constructor; in many languages this is implemented as a
tag value to a variant record (in Pascal) or a union (in C).
\par
An {\tt XYPlot} consists of a color number {\tt color} and a list
of coordinate specifications {\tt [xyplot]}.
An {\tt YPlot} consists of a color specification,
a start and end x coordinate and a list of y values.
A coordinate {\tt xypoint} consists of a x coordinate and a y coordinate.
This type has only one possible set of fields, and no constructor.
Such a type is called a \dfn{tuple type}.
\par
If the same type is defined repeatedly, {\Tm} will merge the definitions.
Thus, the definition file
\begin{listing}
\begin{verbatim}
|| representation of plot data
plot ::= XYPlot xycolor:int points:[xypoint];
plot ::= YPlot ycolor:int xstart:num xend:num points:[num];

xypoint == ( x:num );
xypoint == ( y:num );
\end{verbatim}
\end{listing}
defines the same types as the previously listed file.
Redefinition of constructors is not allowed.
\subsection{Format of the data structure files}
\index{data structures!format}
In general the data structure description consists of a list of
{\em type}\index{type} definitions.
A type is either a \dfn{tuple} type or a \dfn{constructor} type.
In a tuple type only one group of fields is possible,
in a constructor type several different groups of fields are
possible,
and the possible groups are distinguished by the use of a \dfn{constructor}.
For example, the data-structure definitions shown above define two types: 
\verb+plot+ and \verb+xypoint+. The first is a constructor type,
and the second is a tuple type.
\par
Each constructor and tuple contains a number of \dfn{fields}.
An field contains either a type name,
denoting a single field of that type,
or a type name surrounded by square brackets (`{\tt [}' and `{\tt ]}'),
denoting a list of arbitrary length of fields of that type.
Each constructor field must be given a name---called the
\dfn{field name}---by prefixing the type
specification with `{\it name\/}{\tt :}'.
This field name is used to refer to the field.
It is not allowed to use the same field name more than once in the same type,
but the same field name can be used in different types.
\par
The following restrictions are enforced by {\Tm}:
\index{data structure!restrictions|(}
\begin{itemize}
\item
All type and constructor names must be distinct.
\item
All field names (including inherited field names) of a given type must
be distinct. Different types can use the same field name, though.
\end{itemize}
\index{data structure!restrictions|)}
\par
All text starting with the characters `{\tt ||}' up to the end of the line
is comment that is ignored by {\Tm}.
\subsection{Inheritance}
Each type can inherit from an arbitrary number of other types.
This is specified by prefixing the type definition with a number
of superclass definitions, written as \verb"<superclass> +".
For example:
\begin{verbatim}
origin == ( file:string, line:integer );

statement ::= origin +
    StmtIf clause:expr then:[statement] else:[statement] |
    StmtWhile clause:expr body:[statement] ;

symbol == origin + ( name:string );
\end{verbatim}
In many object-oriented languages a type can inherit from at most one
other type. Although {\Tm} does not enforce this restriction, it may
be enforced by the templates for that language.
Other templates may implement the inheritance themselves, and may
require other restrictions.
\subsection{File inclusion}
\index{%include@\verb+%include+}
Type definitions may be interspersed with file inclusion commands.
They are of the form
\begin{verbatim}
%include "subfile.ds";
\end{verbatim}
The file name (in this example \verb+subfile.ds+) must be surrounded by 
double quotes.
An included data structure file may only contain complete data
structure definitions.
No check is done on recursive file inclusion.
\subsection{Definition style}
{\Tm} is designed to handle data structures in a large range of languages.
IT is therefore a bad idea to define data structures that use specific
features of a certain language.
For example,
in {\Miranda} strings are defined as lists of characters ({\tt [char]}).
Since this is probably very inefficient in other languages
(where a general list manipulation mechanism must be used)
it is not a good idea to use {\tt [char]} in the data structure file.
A better solution is to introduce a new type --- e.g. {\tt string} ---
and to specify the exact representation of a {\tt string}
for each language separately.
\section{Textual representation of the data}
\label{sec:textds}
To allow the exchange of data between various programs a standard
text representation is provided:
the {\Miranda} textual representation.
\par
This standard text representation is as follows:
\begin{itemize}
\item
Each constructor and class is represented by the constructor or class
name followed
by the representation of the fields of that constructor or class.
The entire representation may be surrounded by any number of `{\tt (}'~`{\tt )}' pairs
to avoid ambiguity.
\item
Lists are surrounded by `{\tt [}' and `{\tt ]}',
and the members of the list are separated by commas.
\item
Tuples are surrounded by exactly {\em one} \/pair of round brackets
(`{\tt (}' and `{\tt )}'),
and all fields of the tuple are separated by commas (`{\tt ,}').
\item
The representation of primitive cannot be proscribed by standards; it
is entirely dependent on the primitive type involved.
\item
Between constructor and class fields, constructor and class names and
punctuation any number of spaces, tabs, carriage returns, newlines or
form-feeds may be inserted.
Also, any number of comment lines may be inserted.
Comment starts with the characters `{\tt ||}' and ends at the end of the line.
\end{itemize}
\par
For example, a valid text representation of an instance of type {\tt plot}
as defined in section \pageref{plotds} is:
\begin{verbatim}
XYPlot 1
[
    || The points.
    (1.0, 1.0),
    (2.0, 2.0),
    ((-1e9), 1e50)
]
\end{verbatim}
Others are:
\begin{verbatim}
YPlot 1 (-1.0) 1.0 [1,2,3,4,5,6,7,8,9]
XYPlot 1 []
\end{verbatim}
\index{abbreviations|)}
