\chapter{Tm data structures}
\label{s.ds}
\section{Definition of the data structures}
A {\Tm} data structure definition file consists of a series of
definitions of {\Tm} \defn{types}.
A {\Tm} type belongs to one of the following
four meta-types: \defn{class}, \defn{tuple}, \defn{constructor}
or \defn{constructor base}\footnote{In previous versions of Tm
constructors were not considered types, only the constructor base
type. For reasons of regularity this has been changed.}.
\par
The exact syntax of the type definitions is given in appendix~\ref{s.dsgram},
in the following sections an informal overview of each type is given.
\subsection{Fields}
Each type contains a number of \defn{fields}. A field contains a type
name surrounded by an arbitrary number of square bracket pairs (`{\tt
[}' and `{\tt ]}').  A type without brackets denotes a single element of
that type; a type surrounded with one pair of brackets denotes a list of
arbitrary length of elements of that type; a type surrounded with two
pairs of brackets denotes a list of lists, and so on.  Each field must
be given a name---called the \defn{field name}---by prefixing the type
specification with \verb'<name>:'.  This name is used to refer to
the field. It is not allowed to use the same field name more than once
in the same type, but the same field name can be used in different types.
\subsection{The class meta-type}
\index{data structures!class}\index{meta-type!class}
In its simplest form, a class type consists of a list of fields separated
by commas, and surrounded by curly brackets.
Like all type definitions, it must be terminated by a semicolon (`\verb';'').
For example:
\begin{verbatim}
position = { file:tmstring, line:int };
\end{verbatim}
The list of fields can be split into multiple \defn{components} separated
by \verb'+' signs. Thus, the following definition would also be allowed:
\begin{verbatim}
position = { file:tmstring } + { line:int };
\end{verbatim}
A class can also inherit from other types. 
For example:
\begin{verbatim}
ifStatement = statement + { cond:expr, then:block, else:block };
\end{verbatim}
means that the {\tt ifStatement} class inherits from the {\tt statement}
class.
\par
A class can be defined to be \defn{virtual} by using the `\verb'~=''
operator instead of the `\verb'='' operator. For example:
\begin{verbatim}
statement ~= { pos:position };
\end{verbatim}
Labeling a class 'virtual', indicates that the class itself will
never be created, only subclasses of this class.
\par
To allow compact and clear specification of a class with many
subclasses, these subclasses can be specified in the class itself.
For example:
\begin{verbatim}
statement = { pos:position } +
    ifStatement: { cond:expr, then:block, else:block } |
    whileStatement: { cond:expr, body:block } |
    forStatement: { var:string, bound:expr, body:block } |
    assignStatement: { lhs:expr, rhs:expr }
    ;
\end{verbatim}
Every labeled component is called an \defn{alternative};
every alternative defines a subclass with the name of its label.
A class containing alternatives is flagged as virtual.
Thus, the definition above is equivalent with:
\begin{verbatim}
statement ~= { pos:position };
ifStatement = statement + { cond:expr, then:block, else:block };
whileStatement = statement + { cond:expr, body:block };
forStatement = statement + { var:string, bound:expr, body:block };
assignStatement = statement + { lhs:expr, rhs:expr };
\end{verbatim}
\par
A list of components can be grouped by surrounding it with parentheses.
For example:
\begin{verbatim}
expr =
    plusExpr: ( { a:expr } + { b:expr } ) |
    constExpr: { n:int }
    ;
\end{verbatim}
\subsection{The tuple meta-type}
\index{data structures!tuple}\index{meta-type!tuple}
A \defn{tuple} consists of a list of fields separated by commas and
surrounded by parentheses.
Like all type definitions, it must be terminated by a semicolon (`\verb';'').
For example:
\begin{verbatim}
position == ( file:tmstring, line:int );
\end{verbatim}
The `\verb'=='' operator indicates that the following is a tuple type.
\par
A tuple can inherit from other types. For example:
\begin{verbatim}
ifStatement = statement + ( cond:expr, then:block, else:block );
\end{verbatim}
A tuple statement cannot contain alternatives or multiple lists of fields.
\par
Clearly, every tuple type can be converted to an equivalent class type.
Tuple types are mainly provided for backward compatibility with
older versions of {\Tm}.
\subsection{The constructor and constructor-base meta-types}
\index{data structures!constructor}\index{meta-type!constructor}
\index{data structures!constructor base}\index{meta-type!constructor base}
A \defn{constructor} group consists of a number of \defn{constructors}
and a \defn{constructor base} type.
Every constructor consists of a \defn{name}, followed by a 
list of fields separated by whitespace.
Like all type definitions, it must be terminated by a semicolon (`\verb';'').
For example:
\begin{verbatim}
expr ::=
    constExpr n:int |
    plusExpr a:expr b:expr
    ;
\end{verbatim}
Types {\tt constExpr} and {\tt plusExpr} are \defn{constructor} types;
type {\tt expr} is a \defn{constructor base} type.
The `\verb'::='' operator indicates that the following is a group of
constructor type.
\par
A constructor type can inherit. For example:
\begin{verbatim}
operatorExpression ::= expression +
    addExpression a:expr b:expr |
    multiplyExpression a:expr b:expr |
    negateExpression x:expr
    ;
\end{verbatim}
All constructors types are considered to be subclasses of their
constructor base type. All constructor base types are virtual.
\par
If the same constructor base type is defined repeatedly, {\Tm} will merge the
definitions.
Thus, a definition like
\begin{verbatim}
|| representation of plot data
plot ::= XYPlot xycolor:int points:[xypoint];
plot ::= YPlot ycolor:int xstart:num xend:num points:[num];
\end{verbatim}
is allowed, and defines a constructor base type {\tt plot} with two
constructor types.
\par
Clearly, every constructor type can be converted to a similar class type.
Constructor types are mainly provided for backward compatibility with
older versions of {\Tm}.
\subsection{Restrictions}
A few restrictions are enforced on the type definitions:
\index{data structure!restrictions|(}
\begin{itemize}
\item Apart from constructor base types, types cannot be defined twice.
\item A type cannot inherit (directly or indirectly) from the same type
twice.
\item A type cannot have two fields with the same name, or inherit
a field with the same name as one of its own fields.
\end{itemize}
\index{data structure!restrictions|)}
\par
Also, some templates (for example the standard C template) allow inheritance
from only one type.
\subsection{Comment}
All text starting with the characters `{\tt ||}' up to the end of the line
is comment that is ignored by {\Tm}.
For example:
\begin{verbatim}
|| The representation of a position in a file
position = { file:string, line:num };
\end{verbatim}
\subsection{File inclusion}
\index{%include@\verb+%include+}
Type definitions may be interspersed with file inclusion commands.
They are of the form
\begin{verbatim}
%include "subfile.ds";
\end{verbatim}
The file name (in this example \verb+subfile.ds+) must be surrounded by 
double quotes.
An included data structure file may only contain complete data
structure definitions.
No check is done on recursive file inclusion.
\subsection{Definition style}
{\Tm} is designed to handle data structures in a large range of languages.
It is therefore a bad idea to define data structures that use specific
features of a certain language.
For example,
in {\Miranda} strings are defined as lists of characters ({\tt [char]}).
Since this is probably very inefficient in other languages
(where a general list manipulation mechanism must be used)
it is not a good idea to use {\tt [char]} in the data structure file.
A better solution is to introduce a new type --- e.g. {\tt string} ---
and to specify the exact representation of a {\tt string}
for each language separately.
\subsection{A larger example}
The following file shows the use of all meta-types in a more-or-less
useful definition file. The mixing of classes and constructor types
in one file is not realistic, though. In practice either constructors
or classes will be used consistently.
\par
This file will be used in the examples of chapter \ref{s.tm} to demonstrate
the use of the various template language functions.
\verbatiminput{plot.ds}
\label{plotds}
\section{Textual representation of the data}
\label{sec:textds}
To allow the exchange of data between various programs, a standard
text representation is provided:
the {\Miranda} textual representation.
\par
This standard text representation is as follows:
\begin{itemize}
\item
Each constructor and class is represented by the constructor or class
name followed
by the representation of the fields of that constructor or class.
The entire representation may be surrounded by any number of `{\tt (}'~`{\tt )}' pairs
to avoid ambiguity.
\item
Lists are surrounded by `{\tt [}' and `{\tt ]}',
and the members of the list are separated by commas.
\item
Tuples are surrounded by exactly {\em one} \/pair of round brackets
(`{\tt (}' and `{\tt )}'),
and all fields of the tuple are separated by commas (`{\tt ,}').
\item
The representation of primitives cannot be prescribed here; it
is entirely dependent on the primitive type involved.
\item
Between constructor, tuple and class fields, constructor and class
names and punctuation any number of spaces, tabs, carriage returns,
newlines or form-feeds may be inserted.  Also, any number of comment
lines may be inserted.  Comment starts with the characters `{\tt ||}'
and ends at the end of the line.
\end{itemize}
\par
For example, a valid text representation of an instance of type {\tt curve}
as defined in section \pageref{plotds} is:
\begin{verbatim}
XYCurve 1
[
    || The points.
    (1.0, 1.0),
    (2.0, 2.0),
    ((-1e9), 1e50)
]
\end{verbatim}
Others are:
\begin{verbatim}
YCurve 1 (-1.0) 1.0 [1,2,3,4,5,6,7,8,9]
(XYCurve 1 [])
\end{verbatim}
\index{abbreviations|)}
