.. Tm - an interface code generator.
.. Author: C. van Reeuwijk.
..
.. All rights reserved.
..
.. file: calu.ht
.. Tm C support. Variant: array lists, union constructors.
/*** WARNING: THIS IS GENERATED CODE. ***/

.call no_multiple_inheritance "$(need_ds)"
.call no_childless_virtual "$(need_ds)"
.set problem 0
.foreach t ${tuplelist}
.if ${len ${inherits $t}}
.error A tuple should not inherit:
.error $t inherits from ${inherits $t}
.set problem 1
.endif
.if ${len ${inheritors $t}}
.error A tuple should not have inheritors:
.error ${seplist ", " ${inheritors $t}} inherits from $t
.set problem 1
.endif
.endforeach
.if $(problem)
.exit 1
.endif
/* ---- start of ${tplfilename} ---- */
/* External definitions (Version for array list).

   template file:      ${tplfilename}
   datastructure file: ${dsfilename}
   tm version:         $(tmvers)
   tm kernel version:  $(kernel-version)
 */

/* data structures */

/* forward reference typedefs for all types.
 * C does not like the use of undefined types, but does not
 * mind the use of pointers to (yet) undefined types.
 */
.foreach t $(need_ds_list)
typedef struct str_$t_list *$t_list;
.endforeach
.foreach t ${depsort $(need_ds)}
typedef struct str_$t *$t;
.endforeach

.foreach t $(need_ds)
#define $tNIL ($t)0
.endforeach
.foreach t $(need_ds_list)
#define $t_listNIL ($t_list)0
.endforeach

.set tl
.foreach t ${singletypes ${excl $(need_ds) "" ${tuplelist}}}
.append tl ${call rootclass $t}
.endforeach
.set tl ${uniq $(tl)}
.foreach t $(tl)
.set l ${nonvirtual ${inheritsort $t ${subclasses $t}}}
.if ${len $l}
typedef enum en_tags_$t {
    ${seplist ", " ${prefix TAG $l}}
} tags_$t;
.else
typedef int tags_$t;
.endif

.endforeach

#ifdef __cplusplus
.foreach t ${inheritsort $(need_ds)}
.. Structure definitions for all the constructors of the type
.. That have elements (C does not like empty structures or unions).
/* Structure for ${metatype $t} '$t'. */
.switch ${metatype $t}
.case alias
.error Internal error: alias $t still present.
.case constructor constructorbase class
.if ${len ${inherits $t}}
class str_$t: ${prefix "public " ${seplist ", " ${prefix "str_" ${inherits $t}}}} {
.else
class str_$t {
.endif
public:
.if ${len ${inherits $t}}
.else
#ifdef LOGNEW
    long int lognew_id;
#endif
    tags_${call rootclass $t} tag;
.endif
.foreach e ${fields $t}
    ${type $t $e} $e;
.endforeach
};
.case tuple
struct str_$t {
#ifdef LOGNEW
    long int lognew_id;
#endif
.foreach e ${fields $t}
    ${type $t $e} $e;
.endforeach
};
.endswitch

.endforeach
#else
.foreach t ${depsort $(need_ds)}
.. Structure definitions for all the constructors of the type
.. That have elements (C does not like empty structures or unions).
/* Structure for ${metatype $t} '$t'. */
.switch ${metatype $t}
.case alias
.error Internal error: alias $t still present.
.case constructor constructorbase class
struct str_$t {
#ifdef LOGNEW
    long int lognew_id;
#endif
    tags_${call rootclass $t} tag;
.foreach e ${allfields $t}
    ${type $t $e} $e;
.endforeach
};
.case tuple
struct str_$t {
#ifdef LOGNEW
    long int lognew_id;
#endif
.foreach e ${allfields $t}
    ${type $t $e} $e;
.endforeach
.if ${not ${len ${allfields $t}}}
#ifndef LOGNEW
    int _dummy_field;
#endif
.endif
};
.endswitch

.endforeach
#endif

.foreach t $(need_ds_list)
struct str_$t_list {
    unsigned int sz;
    unsigned int room;
    $t *arr;
#ifdef LOGNEW
    long int lognew_id;
#endif
};

.endforeach
/* Type casting macros. */
.foreach t $(need_ds)
#define to_$t(e) (($t)e)
.endforeach

.. new_<type> routines
#ifdef LOGNEW
.foreach t $(want_new)
.if ${isvirtual $t}
/* No new_$t() since this type is virtual. */
.else
#define new_$t(${seplist , ${allfields $t}}) real_new_$t(${seplist , ${allfields $t} __FILE__ __LINE__})
.endif
.endforeach
.foreach t $(want_new_list)
#define new_$t_list() real_new_$t_list(__FILE__,__LINE__)
.endforeach
..
.. slice_<type>() routines
.foreach t $(want_slice_list)
#define slice_$t_list(l,b,e) real_slice_$t_list(l,b,e,__FILE__,__LINE__)
.endforeach
..
.. rdup_<type>() routines
.foreach t $(want_rdup)
#define rdup_$t(e) real_rdup_$t(e,__FILE__,__LINE__)
.endforeach
.foreach t $(want_rdup_list)
#define rdup_$t_list(e) real_rdup_$t_list(e,__FILE__,__LINE__)
.endforeach
..
.. fscan_<type>() routines
.foreach t $(want_fscan)
#define fscan_$t(f,e) real_fscan_$t(f,e,__FILE__,__LINE__)
.endforeach
.foreach t $(want_fscan_list)
#define fscan_$t_list(f,l) real_fscan_$t_list(f,l,__FILE__,__LINE__)
.endforeach
..
.. extractlist_<type>() routines
.foreach t $(want_extractlist_list)
#define extractlist_$t_list(l,b,e,res) real_extractlist_$t_list(l,b,e,res,__FILE__,__LINE__)
.endforeach
#endif

.. new_<type> routines
#ifdef LOGNEW
.foreach t $(want_new)
.if ${isvirtual $t}
/* No new_$t() since this type is virtual. */
.else
.set tl
.foreach e ${allfields $t}
.append tl ${type $t $e}
.endforeach
.if ${len $(tl)}
extern $t real_new_$t( ${seplist ", " $(tl)}, const char *, const int );
.else
extern $t real_new_$t( const char *, const int );
.endif
.endif
.endforeach
.foreach t $(want_new_list)
extern $t_list real_new_$t_list( const char *file, const int line );
.endforeach
#else
.foreach t $(want_new)
.if ${isvirtual $t}
/* No new_$t() since this type is virtual. */
.else
.set tl
.foreach e ${allfields $t}
.append tl ${type $t $e}
.endforeach
.if ${len $(tl)}
extern $t new_$t( ${seplist ", " $(tl)} );
.else
extern $t new_$t( void );
.endif
.endif
.endforeach
.foreach t $(want_new_list)
extern $t_list new_$t_list( void );
.endforeach
#endif
..
.. setroom_<type>_list functions.
.. For this library they are dummy functions.
.foreach t $(want_setroom_list)
extern $t_list setroom_$t_list( $t_list, const unsigned int );
.endforeach
..
.. append_<type>_list() routines.
.foreach t $(want_append_list)
extern $t_list append_$t_list( $t_list, $t );
.endforeach
..
.. reverse_<type>_list() routines.
.foreach t $(want_reverse_list)
extern $t_list reverse_$t_list( $t_list );
.endforeach
..
.. insert_<type>_list() routines.
.foreach t $(want_insert_list)
extern $t_list insert_$t_list( $t_list, const unsigned int, $t  );
.endforeach
..
.. insertlist_<type>_list() routines.
.foreach t $(want_insertlist_list)
extern $t_list insertlist_$t_list( $t_list, const unsigned int, $t_list  );
.endforeach
..
.. delete_<type>_list() routines.
.foreach t $(want_delete_list)
extern $t_list delete_$t_list( $t_list, const unsigned int );
.endforeach
..
.. extract_<type>_list() routines.
.foreach t $(want_extract_list)
extern $t_list extract_$t_list( $t_list, const unsigned int, $t *, int * );
.endforeach
..
.. extractlist_<type>_list() routines.
#ifdef LOGNEW
.foreach t $(want_extractlist_list)
extern $t_list real_extractlist_$t_list( $t_list, unsigned int, unsigned int, $t_list *, const char *, const int );
.endforeach
#else
.foreach t $(want_extractlist_list)
extern $t_list extractlist_$t_list( $t_list, unsigned int, unsigned int, $t_list * );
.endforeach
#endif
..
.. concat_<type>_list() routines
.foreach t $(want_concat_list)
extern $t_list concat_$t_list( $t_list, $t_list );
.endforeach
..
.. fre_<type>_list() routines
.foreach t $(want_fre_list)
extern void fre_$t_list( $t_list );
.endforeach
.foreach t $(want_fre)
extern void fre_$t( $t );
.endforeach
..
.. rfre_<type>_list() routines
.foreach t $(want_rfre_list)
extern void rfre_$t_list( $t_list );
.endforeach
.foreach t $(want_rfre)
extern void rfre_$t( $t );
.endforeach
..
.. print_<type>() routines
.foreach t $(want_print)
extern void print_$t( TMPRINTSTATE *, const $t );
.endforeach
.foreach t $(want_print_list)
extern void print_$t_list( TMPRINTSTATE *, const $t_list );
.endforeach
..
.. fprint_<type>() routines
.foreach t $(want_fprint)
extern void fprint_$t( FILE *, const $t );
.endforeach
.foreach t $(want_fprint_list)
extern void fprint_$t_list( FILE *, const $t_list );
.endforeach
..
.. slice_<type>() routines
.if ${len $(want_slice_list)}
#ifdef LOGNEW
.foreach t $(want_slice_list)
extern $t_list real_slice_$t_list(
 const $t_list l,
 const unsigned int b,
 const unsigned int e,
 const char *_f,
 const int _l
);
.endforeach
#else
.foreach t $(want_slice_list)
extern $t_list slice_$t_list( $t_list, const unsigned int, const unsigned int );
.endforeach
#endif
.endif
..
.. rdup_<type>() routines
.if ${len $(want_rdup) $(want_rdup_list)}
#ifdef LOGNEW
.foreach t $(want_rdup)
extern $t real_rdup_$t( const $t, const char *_f, const int _l );
.endforeach
.foreach t $(want_rdup_list)
extern $t_list real_rdup_$t_list( const $t_list, const char *_f, const int _l );
.endforeach
#else
.foreach t $(want_rdup)
extern $t rdup_$t( const $t );
.endforeach
.foreach t $(want_rdup_list)
extern $t_list rdup_$t_list( const $t_list );
.endforeach
#endif
.endif
..
.. fscan_<type>() routines
.if ${len $(want_fscan) $(want_fscan_list)}
#ifdef LOGNEW
.foreach t $(want_fscan)
extern int real_fscan_$t( FILE *, $t *, const char *, const int );
.endforeach
.foreach t $(want_fscan_list)
extern int real_fscan_$t_list( FILE *, $t_list *, const char *, const int );
.endforeach
#else
.foreach t $(want_fscan)
extern int fscan_$t( FILE *, $t * );
.endforeach
.foreach t $(want_fscan_list)
extern int fscan_$t_list( FILE *, $t_list * );
.endforeach
#endif
.endif
..
.. cmp_<type>() routines
.foreach t $(want_cmp)
extern int cmp_$t( const $t a, const $t b );
.endforeach
.foreach t $(want_cmp_list)
extern int cmp_$t_list( const $t_list a, const $t_list b );
.endforeach
..
.. Misc. functions.
.if ${member flush_$(basename) $(want_misc)}
extern void flush_$(basename)( void );
.endif
.if ${member stat_$(basename) $(want_misc)}
extern void stat_$(basename)( FILE * );
.endif
.if ${member get_balance_$(basename) $(want_misc)}
extern int get_balance_$(basename)( void );
.endif
..
/* ---- end of ${tplfilename} ---- */
/* Code generation required ${processortime} milliseconds. */
