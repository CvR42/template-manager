.. Tm - an interface code generator.
.. Author: C. van Reeuwijk.
..
.. All rights reserved.
..
.. file: calu.ct
.. tm C support. Variant: array lists, union constructors.
..
.. The following variables must be set in tm:
.. basename:     the name of the module. used to generate init_.. and stat_..
.. wantdefs:     the names of the wanted definitions.
..  OR
.. alldefs:      All code.
..
.. The following C pre-processor variables may be defined:
.. STAT          If you want code for statistics.
..               Statistics are written to 'FILE *statstream'.
.. FATAL(msg)    If you want to supply a fatal error handler to print 'msg'.
..               A default is provided.
.. FIRSTROOM     Initial room in lists. Default is 0.
..
.. Possible declaration or #define-ing of statstream must be done
.. outside this module.
/*** WARNING: THIS IS GENERATED CODE. ***/

.if ${or ${member stat_$(basename) $(need_misc)} ${member get_balance_$(basename) $(need_misc)}}
.set statcode 1
.else
.set statcode 0
.endif
/* ---- start of ${tplfilename} ---- */

/* Routines for '$(basename)'.

   template file:      ${tplfilename}
   datastructure file: ${dsfilename}
   tm version:         $(tmvers)
   tm kernel version:  $(kernel-version)
 */

#ifndef FIRSTROOM
#define FIRSTROOM 0
#endif

.if $(statcode)
#ifdef STAT
.foreach t $(need_stat_list)
static long newcnt_$t_list = 0;
static long frecnt_$t_list = 0;
.endforeach

.foreach t $(need_stat)
.if ${member $t ${tuplelist} ${classlist}}
static long newcnt_$t = 0;
static long frecnt_$t = 0;
.endif
.if ${member $t ${ctypelist}}
.foreach c ${conslist $t}
static long newcnt_$c = 0;
static long frecnt_$c = 0;
.endforeach
.endif
.endforeach
#endif

.endif

/* Caching variables.
 *
 * For each type or type list array of CACHESZ elements is maintained that
 * is filled by the fre_<type>() routines. If possible new_<type>() or
 * new_<cons>() uses these elements.
 *
 * All cacheix_<type> variables maintain the index of the first
 * free element in the array.
 */
#ifndef CACHESZ
#define CACHESZ 5
#endif

#ifdef USECACHE
#undef USECACHE
#endif

#if CACHESZ==0
#else
#define USECACHE
#endif

#ifdef USECACHE
.foreach t ${uniq $(need_new_list) $(need_fre_list)}
static short int cacheix_$t_list = 0;
static $t_list cache_$t_list[CACHESZ]; 
.endforeach
.foreach t ${comm ${tuplelist} ${ctypelist} "" ${uniq $(need_new) $(need_fre)}}
static short int cacheix_$t = 0;
static $t cache_$t[CACHESZ];
.endforeach
#endif

static char tm_srcfile[] = __FILE__;

.if $(statcode)
#ifdef STAT
static char tm_allocfreed[] = "%-20s: %6ld allocated, %6ld freed.%s\n";
#endif

.endif
#ifndef FATAL
#define FATAL(msg) tm_fatal(tm_srcfile,__LINE__,msg)
#endif

/* Possible error strings. */
.if ${strlen $(need_delete_list) $(need_extract_list) $(need_insert_list)}
static char tm_nilptr[] = "NIL pointer";
.endif
.if ${strlen ${comm $(need_fscan) "" ${ctypelist}}}
static char tm_badcons[] = "bad constructor for %s: '%s'";
.endif
.if ${strlen $(need_fscan_list)}
static char tm_badeof[] = "unexpected end of file";
.endif
.if ${strlen $(need_slice_list)}
static char tm_badslice[] = "bad slice";
.endif

#ifndef FATALTAG
#define FATALTAG(tag) tm_badtag(tm_srcfile,__LINE__,(int) tag)
#endif

.if ${len $(need_setroom_list)}
/**************************************************
 *    set array room routines                     *
 **************************************************/

.foreach t $(need_setroom_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_setroom_list)
.set stic_$t
.endforeach
.foreach t $(need_setroom_list)
/* Announce that you will need room for 'rm' elements in
    $t_list 'l'.
 */
$(stic_$t)$t_list setroom_$t_list( $t_list l, const unsigned int rm )
{
    if( l->room>=rm ){
	return l;
    }
    if( l->room==0 ){
	l->arr = TM_MALLOC( $t *, rm * sizeof(*(l->arr)) );
    }
    else {
	l->arr = TM_REALLOC( $t *, l->arr, rm * sizeof(*(l->arr)) );
    }
    l->room = rm;
    return l;
}

.endforeach
.endif
.if ${len $(need_new) $(need_new_list)}
/**************************************************
 *    Allocation routines                         *
 **************************************************/

#ifdef LOGNEW
.foreach t $(need_new)
.if ${member $t ${tuplelist} ${classlist}}
.if ${member $t $(want_new)}
#undef new_$t
.endif
#define new_$t(${seplist , ${fields $t inherited}}) real_new_$t(${seplist , ${fields $t inherited} _f _l})
.endif
.if ${member $t ${ctypelist}}
.if ${member $t $(want_new)}
.foreach c ${conslist $t}
#undef new_$c
.endforeach
.endif
.foreach c ${conslist $t}
#define new_$c(${seplist , ${fields $c inherited}}) real_new_$c(${seplist , ${fields $c inherited} _f _l})
.endforeach
.endif
.endforeach
.foreach t $(need_new_list)
.if ${member $t $(want_new_list)}
#undef new_$t_list
.endif
#define new_$t_list() real_new_$t_list(_f,_l)
.endforeach
#endif

.foreach t $(need_new_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_new_list)
.set stic_$t
.endforeach
.foreach t $(need_new_list)
#ifdef LOGNEW
$(stic_$t)$t_list real_new_$t_list( const char *_f, const int _l )
#else
$(stic_$t)$t_list new_$t_list( void )
#endif
{
    $t_list nw;

#ifdef USECACHE
    if( cacheix_$t_list > 0 ){
	nw = cache_$t_list[--cacheix_$t_list];
    }
    else {
#endif
	nw = TM_MALLOC( $t_list, sizeof(*nw) );
#ifdef USECACHE
    }
#endif
    nw->sz = 0;
#if FIRSTROOM==0
    nw->arr = ($t *) 0;
    nw->room = 0;
#else
    nw->arr = TM_MALLOC( $t *, FIRSTROOM*sizeof($t) );
    nw->room = FIRSTROOM;
#endif
.if $(statcode)
#ifdef STAT
    newcnt_$t_list++;
#endif
.endif
#ifdef LOGNEW
    nw->lognew_id = tm_new_logid( _f, _l );
#endif
    return nw;
}

.endforeach
.foreach t $(need_new)
.set stic_$t "static "
.endforeach
.foreach t $(want_new)
.set stic_$t
.endforeach
.foreach t $(need_new)
.if ${member $t ${tuplelist} ${classlist}}
.. new_<tuple>
#ifdef LOGNEW
.set tl ${call ansi_nproto_lognew $t "${fields $t inherited}"}
$(stic_$t)$t real_new_$t( $(tl) )
#else
.set tl ${call ansi_nproto $t "${fields $t inherited}"}
$(stic_$t)$t new_$t( $(tl) )
#endif
{
    $t nw;

#ifdef USECACHE
    if( cacheix_$t > 0 ){
	nw = cache_$t[--cacheix_$t];
    }
    else {
#endif
	nw = TM_MALLOC( $t, sizeof(*nw) );
#ifdef USECACHE
    }
#endif
.foreach e ${fields $t inherited}
    nw->$e = p_$e;
.endforeach
.if $(statcode)
#ifdef STAT
    newcnt_$t++;
#endif
.endif
#ifdef LOGNEW
    nw->lognew_id = tm_new_logid( _f, _l );
#endif
    return nw;
}

.endif
.if ${member $t ${ctypelist}}
.. new_<cons>
.foreach c ${conslist $t}
#ifdef LOGNEW
.set tl ${call ansi_nproto_lognew $c "${fields $c inherited}"}
$(stic_$t)$t real_new_$c( $(tl) )
#else
.set tl ${call ansi_nproto $c "${fields $c inherited}"}
$(stic_$t)$t new_$c( $(tl) )
#endif
{
    $t nw;

#ifdef USECACHE
    if( cacheix_$t > 0 ){
	nw = cache_$t[--cacheix_$t];
    }
    else {
#endif
	nw = TM_MALLOC( $t, sizeof(*nw) );
#ifdef USECACHE
    }
#endif
    nw->tag = TAG$c;
.foreach e ${fields $c inherited}
    cast_$c(nw)->$e = p_$e;
.endforeach
.if $(statcode)
#ifdef STAT
    newcnt_$c++;
#endif
.endif
#ifdef LOGNEW
    nw->lognew_id = tm_new_logid( _f, _l );
#endif
    return nw;
}

.endforeach
.endif
.endforeach
.endif
.if ${len $(need_fre) $(need_fre_list)}
/**************************************************
 *    Freeing routines                            *
 **************************************************/

.foreach t $(need_fre)
.set stic_$t "static "
.endforeach
.foreach t $(want_fre)
.set stic_$t
.endforeach
.foreach t $(need_fre)
.if ${member $t ${tuplelist} ${classlist}}
.. fre_<tuple>
/* Free an element 'e' of type '$t'. */
$(stic_$t)void fre_$t( $t e )
{
    if( e == $tNIL ){
	return;
    }
.if $(statcode)
#ifdef STAT
    frecnt_$t++;
#endif
.endif
#ifdef LOGNEW
    tm_fre_logid( e->lognew_id );
#endif
#ifdef USECACHE
    if( cacheix_$t<CACHESZ ){
	cache_$t[cacheix_$t++] = e;
	return;
    }
#endif
    TM_FREE( e );
}

.endif
.if ${member $t ${ctypelist}}
.. fre_<cons>
/* Free an element 'e' of type '$t'. */
$(stic_$t)void fre_$t( $t e )
{
    if( e == $tNIL ){
	return;
    }
#ifdef LOGNEW
    tm_fre_logid( e->lognew_id );
#endif
.if ${len ${conslist $t}}
.if $(statcode)
#ifdef STAT
    switch( e->tag ){
.foreach c ${conslist $t}
	case TAG$c:
	    frecnt_$c++;
	    break;

.endforeach
	default:
	    FATALTAG( (int) e->tag );
    }
#endif
.endif
.endif
#ifdef USECACHE
    if( cacheix_$t<CACHESZ ){
	cache_$t[cacheix_$t++] = e;
	return;
    }
#endif
    TM_FREE( e );
}

.endif
.endforeach
.foreach t $(need_fre_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_fre_list)
.set stic_$t
.endforeach
.foreach t $(need_fre_list)
/* Free a list of $t elements 'l'. */
$(stic_$t)void fre_$t_list( $t_list l )
{
    if( l == $t_listNIL ){
	return;
    }
#ifdef LOGNEW
    tm_fre_logid( l->lognew_id );
#endif
.if $(statcode)
#ifdef STAT
    frecnt_$t_list++;
#endif
.endif
    if( l->room!=0 ){
	TM_FREE( l->arr );
    }
#ifdef USECACHE
    if( cacheix_$t_list<CACHESZ ){
	cache_$t_list[cacheix_$t_list++] = l;
	return;
    }
#endif
    TM_FREE( l );
}

.endforeach
.endif
.if ${len $(need_append_list)}
/**************************************************
 *    Append routines                             *
 **************************************************/

.call ansi_static append_list "$$t_list append_$$t_list( $$t_list, $$t )"
.foreach t $(need_append_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_append_list)
.set stic_$t
.endforeach
.foreach t $(need_append_list)
/* Append a $t element 'e' to list 'l', and return the new list. */
$(stic_$t)$t_list append_$t_list( $t_list l, $t e )
{
    if( l->sz >= l->room ){
	l = setroom_$t_list( l, 1+(l->sz)+(l->sz) );
    }
    l->arr[l->sz] = e;
    l->sz++;
    return l;
}

.endforeach
.endif
.if ${len $(need_reverse_list)}
/**************************************************
 *    reverse_<type>_list routines                *
 **************************************************/

.foreach t $(need_reverse_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_reverse_list)
.set stic_$t
.endforeach
.foreach t $(need_reverse_list)
/* Reverse the elements in list 'l'. */
$(stic_$t)$t_list reverse_$t_list( $t_list l )
{
    unsigned int ix;
    unsigned int other;
    $t h;
    $t *arr;

    if( l == $t_listNIL ){
	return l;
    }
    ix = 0;
    other = l->sz-1;
    arr = l->arr;
    while( ix<other ){
	h = arr[ix];
	arr[ix] = arr[other];
	arr[other] = h;
	ix++;
	other--;
    }
    return l;
}

.endforeach
.endif
.if ${len $(need_insert_list)}
/**************************************************
 *    insert_<type>_list routines                 *
 **************************************************/

.foreach t $(need_insert_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_insert_list)
.set stic_$t
.endforeach
.foreach t $(need_insert_list)
/* Insert a $t element 'e' to into list 'l' at position 'pos'. */
$(stic_$t)$t_list insert_$t_list( $t_list l, const unsigned int pos, $t e )
{
    unsigned int ix;
    $t *p;
    unsigned int the_pos = pos;

    if( l == $t_listNIL ){
	FATAL( tm_nilptr );
    }
    if( l->sz >= l->room ){
	l = setroom_$t_list( l, 1+(l->sz)+(l->sz) );
    }
    if( the_pos>l->sz ){
	the_pos = l->sz;
    }
    p = l->arr;
    for( ix=l->sz; ix>the_pos; ix-- ){
	p[ix] = p[ix-1];
    }
    l->sz++;
    p[the_pos] = e;
    return l;
}

.endforeach
/**************************************************
 *    Concatenate routines                        *
 **************************************************/

.foreach t $(need_concat_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_concat_list)
.set stic_$t
.endforeach
.foreach t $(need_concat_list)
/* Concatenate $t list 'lb' after $t list 'la'.
   The list descriptor of list 'lb' is freed,
   since its contents has been moved to 'la'.
 */
$(stic_$t)$t_list concat_$t_list( $t_list la, $t_list lb )
{
    unsigned int cnt;
    $t *sp;
    $t *dp;

    la = setroom_$t_list( la, la->sz+lb->sz );
    cnt = lb->sz;
    sp = lb->arr;
    dp = &la->arr[la->sz];
    while( cnt!=0 ){
	*dp++ = *sp++;
	cnt--;
    }
    la->sz += lb->sz;
    fre_$t_list( lb );
    return la;
}

.endforeach
.endif
.if ${len $(need_rfre) $(need_rfre_list)}
/**************************************************
 *    Recursive freeing routines                  *
 **************************************************/

.. Forward declarations
.call ansi_static rfre_list "void rfre_$$t_list( $$t_list )"
.call ansi_static rfre "void rfre_$$t( $$t )"
.foreach t ${depsort $(need_rfre)}
.set stic_$t "static "
.endforeach
.foreach t $(want_rfre)
.set stic_$t
.endforeach
.foreach t ${depsort $(need_rfre)}
/* Recursively free an element 'e' of type '$t'
   and all elements in it.
 */
.if ${member $t ${tuplelist} ${classlist}}
$(stic_$t)void rfre_$t( $t e )
{
    if( e == $tNIL ){
	return;
    }
.foreach e ${fields $t inherited}
    rfre_${type $t $e}( e->$e );
.endforeach
    fre_$t( e );
}

.endif
.if ${member $t ${ctypelist}}
$(stic_$t)void rfre_$t( $t e )
{
    if( e == $tNIL ){
	return;
    }
.if ${len ${conslist $t}}
    switch( e->tag ){
.foreach c ${conslist $t}
	case TAG$c:
.foreach e ${fields $c inherited}
	    rfre_${type $c $e}( cast_$c(e)->$e );
.endforeach
	    break;

.endforeach
	default:
	    FATALTAG( (int) e->tag );
    }
.endif
    fre_$t( e );
}

.endif
.endforeach
.foreach t $(need_rfre_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_rfre_list)
.set stic_$t
.endforeach
.foreach t $(need_rfre_list)
/* Recursively free a list of elements 'e' of type $t. */
$(stic_$t)void rfre_$t_list( $t_list e )
{
    unsigned int ix;

    if( e == $t_listNIL ){
	return;
    }
    for( ix=0; ix<e->sz; ix++ ){
	rfre_$t( e->arr[ix] );
    }
    fre_$t_list( e );
}

.endforeach
.endif
.if ${len $(need_print) $(need_print_list)}
/**************************************************
 *    print_<type> and print_<type>_list routines *
 **************************************************/

.. Forward declarations
.call ansi_static print_list "void print_$$t_list( TMPRINTSTATE *st, const $$t_list )"
.call ansi_static print "void print_$$t( TMPRINTSTATE *st, const $$t )"
.foreach t ${depsort $(need_print)}
.set stic_$t "static "
.endforeach
.foreach t $(want_print)
.set stic_$t
.endforeach
.foreach t $(need_print)
/* Print an element 't' of type '$t'
   using print optimizer.
 */
$(stic_$t)void print_$t( TMPRINTSTATE *st, const $t t )
{
.if ${member $t ${tuplelist} ${classlist}}
    if( t == $tNIL ){
	tm_printword( st, "@" );
	return;
    }
    tm_opentuple( st );
.foreach e ${fields $t inherited}
    print_${type $t $e}( st, t->$e );
.endforeach
    tm_closetuple( st );
.endif
.if ${member $t ${ctypelist}}
    if( t == $tNIL ){
	tm_printword( st, "@" );
	return;
    }
    tm_opencons( st );
.if ${len ${conslist $t}}
    switch( t->tag ){
.foreach c ${conslist $t}
	case TAG$c:
	    tm_printword( st, "$c" );
.foreach e ${fields $c inherited}
	    print_${type $c $e}( st, cast_$c(t)->$e );
.endforeach
	    break;

.endforeach
	default:
	    FATALTAG( (int) t->tag );
    }
.endif
    tm_closecons( st );
.endif
}

.endforeach
.foreach t $(need_print_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_print_list)
.set stic_$t
.endforeach
.foreach t $(need_print_list)
/* Print a list of elements 'l' of type '$t'
   using print optimizer.
 */
$(stic_$t)void print_$t_list( TMPRINTSTATE *st, const $t_list l )
{
    unsigned int ix;

    if( l == $t_listNIL ){
	tm_printword( st, "@" );
	return;
    }
    tm_openlist( st );
    for( ix=0; ix<l->sz; ix++ ){
	print_$t( st, l->arr[ix] );
    }
    tm_closelist( st );
}

.endforeach
.endif
.if ${len $(need_fprint) $(need_fprint_list)}
/***************************************************
 *   fprint_<type> and fprint_<type>_list routines *
 ***************************************************/

.. Forward declarations
.call ansi_static fprint_list "void fprint_$$t_list( FILE *f, const $$t_list l )"
.call ansi_static fprint "void fprint_$$t( FILE *f, const $$t e )"
.foreach t $(need_fprint)
.set stic_$t "static "
.endforeach
.foreach t $(want_fprint)
.set stic_$t
.endforeach
.foreach t $(need_fprint)
/* Print a $t 't' to file 'f'. */
$(stic_$t)void fprint_$t( FILE *f, const $t t )
{
    if( t == $tNIL ){
	fputs( "@ ", f );
	return;
    }
    putc( '(', f );
.if ${member $t ${tuplelist} ${classlist}}
.set first 1
.foreach e ${fields $t inherited}
.if $(first)
.set first 0
.else
    fputs( ",\n", f );
.endif
    fprint_${type $t $e}( f, t->$e );
.endforeach
.endif
.if ${member $t ${ctypelist}}
.if ${len ${conslist $t}}
    switch( t->tag ){
.foreach c ${conslist $t}
	case TAG$c:
	    fputs( "$c", f );
.foreach e ${fields $c inherited}
	    putc( ' ', f );
	    fprint_${type $c $e}( f, cast_$c(t)->$e );
.endforeach
	    break;

.endforeach
	default:
	    FATALTAG( (int) t->tag );
    }
.endif
.endif
    fputs( ")\n", f );
}

.endforeach
.foreach t $(need_fprint_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_fprint_list)
.set stic_$t
.endforeach
.foreach t $(need_fprint_list)
/* Print a $t list 'l' to file 'f'. */
$(stic_$t)void fprint_$t_list( FILE *f, const $t_list l )
{
    unsigned int ix;

    if( l == $t_listNIL ){
	fputs( "@ ", f );
	return;
    }
    putc( '[', f );
    for( ix=0; ix<l->sz; ix++ ){
	if( ix!=0 ){
	    fputc( ',', f );
	}
	fprint_$t( f, l->arr[ix] );
    }
    fputs( "]\n", f );
}

.endforeach
.endif
.if ${len $(need_rdup) $(need_rdup_list)}
/**************************************************
 *    Duplication routines                        *
 **************************************************/

#ifdef LOGNEW
.foreach t $(need_rdup)
.if ${member $t $(want_rdup)}
#undef rdup_$t
.endif
#define rdup_$t(e) real_rdup_$t(e,_f,_l)
.endforeach
.foreach t $(need_rdup_list)
.if ${member $t $(want_rdup_list)}
#undef rdup_$t_list
.endif
#define rdup_$t_list(l) real_rdup_$t_list(l,_f,_l)
.endforeach
.. Forward declarations
.call ansi_static rdup_list "$$t_list real_rdup_$$t_list( const $$t_list l, const char *_f, const int _l )"
.call ansi_static rdup "$$t real_rdup_$$t( const $$t e, const char *_f, const int _l )"
#else
.call ansi_static rdup_list "$$t_list rdup_$$t_list( const $$t_list l )"
.call ansi_static rdup "$$t rdup_$$t( const $$t e )"
#endif
.foreach t $(need_rdup)
.set stic_$t "static "
.endforeach
.foreach t $(want_rdup)
.set stic_$t
.endforeach
.foreach t $(need_rdup)
/* Recursively duplicate a $t element 'e'. */
#ifdef LOGNEW
$(stic_$t)$t real_rdup_$t( const $t e, const char *_f, const int _l )
#else
$(stic_$t)$t rdup_$t( const $t e )
#endif
{
.if ${member $t ${tuplelist} ${classlist}}
.foreach e ${fields $t inherited}
    ${type $t $e} i_$e;
.endforeach

    if( e == $tNIL ){
	return $tNIL;
    }
.foreach e ${fields $t inherited}
    i_$e = rdup_${type $t $e}( e->$e );
.endforeach
    return new_$t( ${seplist ", " ${prefix "i_" ${fields $t inherited}}} );
.endif
.if ${member $t ${ctypelist}}
.. rdup_<cons>
    if( e == $tNIL ){
	return $tNIL;
    }
.if ${len ${conslist $t}}
    switch( e->tag ){
.foreach c ${conslist $t}
	case TAG$c:
	{
.foreach e ${fields $c inherited}
	    ${type $c $e} i_$e;
.endforeach

.foreach e ${fields $c inherited}
	    i_$e = rdup_${type $c $e}( cast_$c(e)->$e );
.endforeach
	    return new_$c( ${seplist ", " ${prefix "i_" ${fields $c inherited}}} );
	}

.endforeach
	default:
	    FATALTAG( (int) e->tag );
    }
.else
#ifdef LOGNEW
    (void) _f;
    (void) _l;
#endif
.endif
    return $tNIL;
.endif
}

.endforeach
.foreach t $(need_rdup_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_rdup_list)
.set stic_$t
.endforeach
.foreach t $(need_rdup_list)
/* Recursively duplicate $t list 'l'. */
#ifdef LOGNEW
$(stic_$t)$t_list real_rdup_$t_list( const $t_list l, const char *_f, const int _l )
#else
$(stic_$t)$t_list rdup_$t_list( const $t_list l )
#endif
{
    unsigned int ix;
    $t_list nw;
    $t *ar;
    $t *o_r;

    if( l == $t_listNIL ){
	return $t_listNIL;
    }
    nw = setroom_$t_list( new_$t_list(), l->sz );
    ar = nw->arr;
    o_r = l->arr;
    for( ix=0; ix<l->sz; ix++ ){
	*ar++ = rdup_$t( *o_r++ );
    }
    nw->sz = l->sz;
    return nw;
}

.endforeach
.endif
.if ${len $(need_slice_list)}
/**************************************************
 *    Slice routines                              *
 **************************************************/

#ifdef LOGNEW
.foreach t $(need_slice_list)
.if ${member $t $(want_slice_list)}
#undef slice_$t_list
.endif
#define slice_$t_list(l,b,e) real_slice_$t_list(l,b,e,_f,_l)
.endforeach
#endif
.. Forward declarations
.foreach t $(need_slice_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_slice_list)
.set stic_$t
.endforeach
.foreach t $(need_slice_list)
/* Recursively duplicate elements from $t list 'l',
 * starting at element 'b', and ending at element
 * 'e'. Element 'e' is not copied.
 */
#ifdef LOGNEW
$(stic_$t)$t_list real_slice_$t_list(
    const $t_list l,
    const unsigned int b,
    const unsigned int parm_e,
    const char *_f,
    const int _l
)
#else
$(stic_$t)$t_list slice_$t_list(
    const $t_list l,
    const unsigned int b,
    const unsigned int parm_e
)
#endif
{
    unsigned int ix;
    $t_list nw;
    unsigned int e = parm_e;

    if( l == $t_listNIL ){
	return $t_listNIL;
    }
    nw = new_$t_list();
    if( e>l->sz ){
	e = l->sz;
    }
    if( b>e ){
	FATAL( tm_badslice );
    }
    nw = setroom_$t_list( nw, e-b );
    for( ix=b; ix<e; ix++ ){
	nw = append_$t_list( nw, rdup_$t( l->arr[ix] ) );
    }
    return nw;
}

.endforeach
.endif
.if ${len $(need_cmp) $(need_cmp_list)}
/**************************************************
 *    Comparison routines.                        *
 **************************************************/

.. Forward declarations
.call ansi_static cmp_list "int cmp_$$t_list( const $$t_list a, const $$t_list b )"
.call ansi_static cmp "int cmp_$$t( const $$t a, const $$t b )"
.foreach t $(need_cmp)
.if ${member $t $(want_cmp)}
.set stat
.else
.set stat "static "
.endif
.if ${member $t ${tuplelist} ${classlist}}
.. cmp_<tuple>
/* Compare two $t tuples. */
$(stat)int cmp_$t( const $t a, const $t b )
{
    int res;

    res = 0;
.. A small optimization, but also takes care of NIL.
    if( a == b ){
	return res;
    }
    if( a == $tNIL ){
	return -1;
    }
    if( b == $tNIL ){
	return 1;
    }
.set first 1
.foreach e ${fields $t inherited}
.set tn ${type $t $e}
.if $(first)
.set first 0
.else
    if( res != 0 ){
	return res;
    }
.endif
    res = cmp_$(tn)( a->$e, b->$e );
.endforeach
    return res;
}

.endif
.if ${member $t ${ctypelist}}
.. cmp_<cons>
/* Compare two $t constructors. */
$(stat)int cmp_$t( const $t a, const $t b )
{
    int res;

.. A small optimization, but also takes care of NIL.
    if( a == b ){
	return 0;
    }
    if( a == $tNIL ){
	return -1;
    }
    if( b == $tNIL ){
	return 1;
    }
.if ${len ${conslist $t}}
    res = ( (int)a->tag - (int)b->tag);
    if( res != 0 ){
	return res;
    }
    switch( a->tag )
    {
.foreach c ${conslist $t}
	case TAG$c:
.set first 1
.foreach e ${fields $c inherited}
.if $(first)
.set first 0
.else
	    if( res != 0 ){
		break;
	    }
.endif
	    res = cmp_${type $c $e}( cast_$c(a)->$e, cast_$c(b)->$e );
.endforeach
	    break;

.endforeach
	    default:
		FATALTAG( (int) a->tag );
    }
.else
    res = 0;
.endif
    return res;
}

.endif
.endforeach
.foreach t $(need_cmp_list)
.if ${member $t $(want_cmp_list)}
.set stat
.else
.set stat "static "
.endif
/* Compare two $t lists. */
$(stat)int cmp_$t_list( const $t_list a, const $t_list b )
{
    int res;
    unsigned int ix;

.. A small optimization, but also takes care of NIL.
    if( a == b ){
	return 0;
    }
    if( a == $t_listNIL ){
	return -1;
    }
    if( b == $t_listNIL ){
	return 1;
    }
    ix = 0;
    while( ix<a->sz || ix<b->sz ){
	if( ix>=a->sz ){
	    return -1;
	}
	if( ix>=b->sz ){
	    return 1;
	}
	res = cmp_$t( a->arr[ix], b->arr[ix] );
	if( res != 0 ){
	    return res;
	}
	ix++;
    }
    return 0;
}

.endforeach
.endif
.if ${len $(need_fscan) $(need_fscan_list)}
/**************************************************
 *    Scan routines.                              *
 **************************************************/

#ifdef LOGNEW
.foreach t $(need_fscan)
.if ${member $t $(want_fscan)}
#undef fscan_$t
.endif
#define fscan_$t(f,ep) real_fscan_$t(f,ep,_f,_l)
.endforeach
.foreach t $(need_fscan_list)
.if ${member $t $(want_fscan_list)}
#undef fscan_$t_list
.endif
#define fscan_$t_list(f,lp) real_fscan_$t_list(f,lp,_f,_l)
.endforeach
.. Forward declarations
.call ansi_static fscan_list "int real_fscan_$$t_list( FILE *, $$t_list *, const char *_f, const int _l )"
.call ansi_static fscan "int real_fscan_$$t( FILE *, $$t *, const char *_f, const int _l )"
#else
.. Forward declarations
.call ansi_static fscan_list "int fscan_$$t_list( FILE *f, $$t_list *p )"
.call ansi_static fscan "int fscan_$$t( FILE *f, $$t *p )"
#endif
.foreach t $(need_fscan)
.set stic_$t "static "
.endforeach
.foreach t $(want_fscan)
.set stic_$t
.endforeach
.foreach t $(need_fscan)
.if ${member $t ${tuplelist} ${classlist}}
.. tuple type
/* Read a tuple of type $t
   from file 'f' and allocate space for it.
   Set the pointer 'p' to point to that structure.
 */
#ifdef LOGNEW
$(stic_$t)int real_fscan_$t( FILE *f, $t *p, const char *_f, const int _l )
#else
$(stic_$t)int fscan_$t( FILE *f, $t *p )
#endif
{
    int err;
    int c;
.foreach e ${fields $t inherited}
    ${type $t $e} l_$e;
.endforeach

.. Note that separate assignment is necessary, since there may
.. be weird <type>NIL definitions ..
.foreach e ${fields $t inherited}
    l_$e = ${type $t $e}NIL;
.endforeach
    *p = $tNIL;
    if( tm_fscanspace( f ) ){
	return 1;
    }
    c = getc( f );
    if( c == '@' ){
	return 0;
    }
    ungetc( c, f );
    err = tm_fneedc( f, '(' );
    if( err ){
	return 1;
    }
.set first 1
.foreach e ${fields $t inherited}
.set tn ${type $t $e}
.if $(first)
.set first 0
.else
    if( !err ){
	err = tm_fneedc( f, ',' );
    }
.endif
    if( !err ){
	err = fscan_$(tn)( f, &l_$e );
    }
.endforeach
    *p = new_$t( ${seplist ", " ${prefix " l_" ${fields $t inherited}}} );
    if( err ){
	return 1;
    }
    return tm_fneedc( f, ')' );
}

.endif
.if ${member $t ${ctypelist}}
/* Read an instance of a datastructure of type $t.
   from file 'f' and allocate space for it. Set the pointer 'p' to
   point to that structure.
 */
.. First, determine the length of the largest constructor name.
.set maxlen 1
.foreach c ${conslist $t}
.set maxlen ${max $(maxlen) ${strlen $c}}
.endforeach
.. Add some space for '\0' and safety..
.set maxlen $[$(maxlen)+4]
#ifdef LOGNEW
$(stic_$t)int real_fscan_$t( FILE *f, $t *p, const char *_f, const int _l )
#else
$(stic_$t)int fscan_$t( FILE *f, $t *p )
#endif
{
    int n;
    int c;
    int err;
.if ${len ${conslist $t}}
    char tm_word[$(maxlen)];	/* Largest constructor should fit in it.. */
.endif

.if ${not ${len ${conslist $t}}}
#ifdef LOGNEW
    (void) _f;
    (void) _l;
#endif
.endif
    *p = $tNIL;
    n = tm_fscanopenbrac( f );
    err = tm_fscanspace( f );
    if( err ){
	return 1;
    }
    c = getc( f );
    if( c == '@' ){
	return tm_fscanclosebrac( f, n );
    }
    ungetc( c, f );
.if ${len ${conslist $t}}
    if( tm_fscancons( f, tm_word, $(maxlen) ) ){
	return 1;
    }
.. First time in loop there should be no 'else' before the if,
.. in all other cases there should.
.set els
.foreach c ${conslist $t}
    $(els)if( strcmp( tm_word, "$c" ) == 0 ){
.foreach e ${fields $c inherited}
	${type $c $e} l_$e;
.endforeach

.foreach e ${fields $c inherited}
.set tn ${type $c $e}
	l_$e = $(tn)NIL;
	if( !err ){
	    err = fscan_$(tn)( f, &l_$e );
	}
.endforeach
	*p = new_$c( ${seplist ", " ${prefix " l_" ${fields $c inherited}}} );
    }
.set els "else "
.endforeach
    else {
	(void) sprintf( tm_errmsg, tm_badcons, "$t", tm_word );
	return 1;
    }
    if( err ){
	return 1;
    }
.endif
    return tm_fscanclosebrac( f, n );
}

.endif
.endforeach
.foreach t $(need_fscan_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_fscan_list)
.set stic_$t
.endforeach
.foreach t $(need_fscan_list)
/* Read an instance of a list of datastructure of type $t
   from file 'f' and allocate space for it. Set the pointer 'p' to
   point to that structure.
 */
#ifdef LOGNEW
$(stic_$t)int real_fscan_$t_list( FILE *f, $t_list *p, const char *_f, const int _l )
#else
$(stic_$t)int fscan_$t_list( FILE *f, $t_list *p )
#endif
{
    int err;
    int c;
    int n;
    $t nw;

    *p = $t_listNIL;
    n = tm_fscanopenbrac( f );
    err = tm_fscanspace( f );
    if( err ){
	return 1;
    }
    c = getc( f );
    if( c == '@' ){
	return tm_fscanclosebrac( f, n );
    }
    ungetc( c, f );
    if( tm_fneedc( f, '[' ) ){
	return 1;
    }
    *p = new_$t_list();
    if( tm_fscanspace( f ) ){
	return 1;
    }
    c = getc( f );
    if( c == ']' ){
	return 0;
    }
    if( c == EOF ){
	(void) strcpy( tm_errmsg, tm_badeof );
	return 1;
    }
    ungetc( c, f );
    for(;;){
	if( !err ){
	    err = fscan_$t( f, &nw );
	}
	*p = append_$t_list( *p, nw );
	if( err || tm_fscanspace( f ) ){
	    return 1;
	}
	c = getc( f );
	if( c == EOF ){
	    (void) strcpy( tm_errmsg, tm_badeof );
	    return 1;
	}
	if( c != ',' ){
	    ungetc( c, f );
	    break;
	}
    }
    if( tm_fneedc( f, ']' ) ){
	return 1;
    }
    return tm_fscanclosebrac( f, n );
}

.endforeach
.endif
.if ${len $(need_delete_list)}
/**************************************************
 *    delete_<type>_list routines                 *
 **************************************************/

.call ansi_static delete_list "$$t_list delete_$$t_list( $$t_list, const unsigned int )"
.foreach t $(need_delete_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_delete_list)
.set stic_$t
.endforeach
.foreach t $(need_delete_list)
/* Delete '$t' element at position 'pos' in list 'l'. */
$(stic_$t)$t_list delete_$t_list( $t_list l, const unsigned int pos )
{
    unsigned int ix;

    if( l == $t_listNIL ){
	FATAL( tm_nilptr );
    }
    if( pos >= l->sz ){
	return l;
    }
    rfre_$t( l->arr[pos] );
    l->sz--;
    for( ix=pos; ix<l->sz; ix++ ){
	l->arr[ix] = l->arr[ix+1];
    }
    return l;
}

.endforeach
.endif
.if ${len $(need_extract_list)}
/**************************************************
 *    extract_<type>_list routines                 *
 **************************************************/

.call ansi_static extract_list "$$t_list extract_$$t_list( $$t_list, const unsigned int, $$t *, int * )"
.foreach t $(need_extract_list)
.set stic_$t "static "
.endforeach
.foreach t $(want_extract_list)
.set stic_$t
.endforeach
.foreach t $(need_extract_list)
/* Extract '$t' element at position 'pos' in list 'l'. */
$(stic_$t)$t_list extract_$t_list(
    $t_list l,
    const unsigned int pos,
    $t *e,
    int *valid
)
{
    unsigned int ix;

    if( l == $t_listNIL ){
	FATAL( tm_nilptr );
    }
    if( pos >= l->sz ){
	*valid = 0;
	return l;
    }
    *valid = 1;
    *e = l->arr[pos];
    l->sz--;
    for( ix=pos; ix<l->sz; ix++ ){
	l->arr[ix] = l->arr[ix+1];
    }
    return l;
}

.endforeach
.endif
.if ${len $(need_misc)}
/**************************************************
 *    Miscellaneous routines                      *
 **************************************************/
.if ${member flush_$(basename) $(need_misc)}
/* Flush the allocation caches. */
void flush_$(basename)()
{
#ifdef USECACHE
    short int ix;

.foreach t ${uniq $(need_new_list) $(need_fre_list)}
    for( ix=0; ix<cacheix_$t_list; ix++ ){
	TM_FREE( cache_$t_list[ix] );
    }
    cacheix_$t_list = 0;
.endforeach
.foreach t ${uniq $(need_new) $(need_fre)}
    for( ix=0; ix<cacheix_$t; ix++ ){
	TM_FREE( cache_$t[ix] );
    }
    cacheix_$t = 0;
.endforeach
#endif
}

.endif
.if ${member stat_$(basename) $(need_misc)}
/* Print allocation and freeing statistics to file 'f'. */
void stat_$(basename)( FILE *f )
{
#ifdef STAT
.foreach t $(need_stat)
.if ${member $t ${tuplelist} ${classlist}}
    fprintf(
	f,
	tm_allocfreed,
	"$t",
	newcnt_$t,
	frecnt_$t,
	((newcnt_$t==frecnt_$t)? "": "<-")
    );
.endif
.if ${member $t ${ctypelist}}
.foreach c ${conslist $t}
    fprintf(
	f,
	tm_allocfreed,
	"$c",
	newcnt_$c,
	frecnt_$c,
	((newcnt_$c==frecnt_$c)? "": "<-")
    );
.endforeach
.endif
.endforeach
.foreach t $(need_stat_list)
    fprintf(
	f,
	tm_allocfreed, "$t_list",
	newcnt_$t_list,
	frecnt_$t_list,
	((newcnt_$t_list==frecnt_$t_list)? "": "<-")
    );
.endforeach
#else
    (void) f; /* to prevent 'f unused' from compiler and lint */
#endif
}

.endif
.if ${member get_balance_$(basename) $(need_misc)}
/* Return -1 if there is a structure that has freed more than allocated, or
 * else return 1 if there is a structure that has been freed less than
 * allocated, or else return 0.
 */
int get_balance_$(basename)( void )
{
    int res;

    res = 0;
#ifdef STAT
.foreach t $(need_stat_list)
    if( newcnt_$t_list<frecnt_$t_list ){
        return -1;
    }
    if( newcnt_$t_list>frecnt_$t_list ){
        res = 1;
    }
.endforeach
.foreach t $(need_stat)
.if ${member $t ${tuplelist} ${classlist}}
    if( newcnt_$t<frecnt_$t ){
        return -1;
    }
    if( newcnt_$t>frecnt_$t ){
        res = 1;
    }
.endif
.if ${member $t ${ctypelist}}
.foreach c ${conslist $t}
    if( newcnt_$c<frecnt_$c ){
        return -1;
    }
    if( newcnt_$c>frecnt_$c ){
        res = 1;
    }
.endforeach
.endif
.endforeach
#endif
    return res;
}

.endif
.endif
/* ---- end of ${tplfilename} ---- */
/* Code generation required ${processortime} milliseconds. */
