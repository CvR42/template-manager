\chapter{The implementation of Tm}
\label{s.impl}
\section{General information}
This appendix describes the implementation of {\Tm} and its language templates.
Since most code of {\Tm} and its templates is provided with comments that
describe the purpose of each definition.
That information will not be repeated in this appendix.
Instead the appendix describes the global structure of the code.
\section{Tm}
{\Tm} takes a data structure description file and a template file,
and executes the commands in the template file to generate output.
\subsection{Files}
The following table describes the most important files of the {\Tm} sources.
Most of the {\tt .c} files have an associated {\tt .h} file that
contains {\tt extern} declarations of all functions that are supposed
to be visible outside that file.
All other files that use one of these functions have an
{\tt \#include} of that {\tt .h} file.
\par
\begin{tabular}{lp{\descwidth}}
{\tt debug.c} & Handles parsing of the command line debugging flags. \\
{\tt ds.ds} & Data structures for representation of data structures. \\
{\tt refex.c} & Regular expression pattern matcher. \\
{\tt tm.1} & Manual pages.\\
{\tt tm.c} & Main program. Setup, command line parsing and termination. \\
{\tt tmdefs.h} & General definitions for {\Tm}. \\
{\tt tmerror.c} & Error handling. \\
{\tt tmexpr.c} & Handling of numerical expressions. That is,
evaluation of strings within \verb!$[]!. \\
{\tt tmfn.c} & Handling of functions. That is, evaluation of strings
within \verb!${}!. \\
{\tt tmglobal.c} & Declaration of global variables. \\
{\tt tmgram.y} & {\tt yacc} grammar for parsing of data structure
definitions. \\
{\tt tmlex.c} & Lexical analysis for {\tt tmgram.y}. \\
{\tt tmmisc.c} & Assorted low-level functions. \\
{\tt tmstring.c} & String handling. E.g. separation of a string into words.\\
{\tt tmtrans.c} & Template file parsing and evaluation. \\
{\tt tmvar.c} & Tm variable handling. \\
{\tt tplelm.ds} & Data structures for representation of template lines. \\
\end{tabular}

\subsection{debugging variables}
{\Tm} has a number of debugging flags
that can be switched on from the command line by the
option \verb!-d<debugflags>!,
where each \verb!<debugflag>! is character representing a debug switch.
\par
{\Tm} supports the following flags:
\par
\begin{tabular}{lll}
character & variable & description \\
\hline
{\tt e} & {\tt sevaltr} & tracing of string evaluations \\
{\tt f} & {\tt fntr} & tracing of function evaluations \\
{\tt l} & {\tt listing} & list parsetree \\
{\tt m} & {\tt maintr} & tracing of main actions \\
{\tt s} & {\tt stat} & statistics \\
{\tt v} & {\tt vartr} & variable tracing \\
{\tt x} & {\tt lextr} & tracing of lexical analyzer \\
{\tt y} & {\tt yydebug} & tracing of YACC parser \\
\end{tabular}
\par
For example, the command line option \verb!-desx! sets the variables
{\tt sevaltr}, {\tt stat} and {\tt lextr} to true.
The table shown above is in essence the table {\tt flagtab[]}
in the file {\tt tm.c}.
The function {\tt setdbflags()} is given this table and a string of debug
flags as parameters, and turns on the appropriate flags.
The function {\tt dbreport()} indicates which flags are turned on,
and the function {\tt dbhelp()} gives a list of all available options.
The latter is used for \verb!tm -h!.
\subsection{error handling}
Errors are handled by the functions in {\tt tmerror.c}.
To print an error message, the function {\tt error()} is invoked.
If the global {\tt char} array {\tt errpos} contains a string (that
is, if \verb@errpos[0]!='\0'@),
it is printed before the error message. 
Similarly, if the global {\tt char} array {\tt errarg} contains a string,
it is printed after the error message.
Both arrays have length {\tt ERRARGLEN}, that is at least 80.
Using {\tt errpos[]} and {\tt errarg[]} may seem a clumsy way to pass
parameters to {\tt error()},
but this way it is possible to use {\tt sprintf()} to construct position
and argument indications for the error message that may have any form.
Unfortunately {\tt errpos[]} and {\tt errarg[]} have a constant size,
but there is no easy way around this.
\subsection{flow of control}
Globally, {\Tm} executes the following steps:
\begin{itemize}
\item Initialization.
\item Command line parsing.
\item Data structure file parsing.
\item Template file parsing.
\item Output generation.
\item Termination.
\end{itemize}
Only data structure file parsing, template file parsing and output
generation will be discussed in detail.
\par
The global execution steps of {\Tm} can be made visible by setting
the variable {\tt maintr} to {\tt TRUE}.
This can be done through the command line option {\tt -dm}.
\subsection{data structure file parsing}
Data structure file parsing is done by a {\tt yacc} parser defined in
the file {\tt tmgram.y}.
During parsing a list of instances of type {\tt ds} is constructed as
defined in the file {\tt ds.ds}.
During parsing some checks are done on the data structure definitions.
The actions of the parser can be made visible by
setting the variable {\tt yyparse} to {\tt TRUE}.
This can be done through the command line option {\tt -dy}.
\par
Lexical analysis, as required by {\tt yacc} is done by functions in the file
{\tt tmlex.c}.
This is a general lexical analyzer with tables filled with specific
information for this program:
\begin{itemize}
\item The initialized array {\tt toktab[]} contains a list of special
character combinations like `\verb!::=!'.
\item The initialized array {\tt rwtab[]} contains a list of reserved words
      (in this case empty).
\end{itemize}
It is possible to print the tokens found by
the lexical analyzer by setting the variable {\tt lextr} to {\tt TRUE}.
This can be done through the command line option {\tt -dx}.
\par
The parse tree of the data structures can be printed by setting the
variable {\tt listing} to {\tt TRUE}.
This can be done through the command line option {\tt -dl}.
\subsection{language template parsing}
Before output is generated the entire template file is parsed for line
commands, and stored in a parse tree consisting of instances of type
{\tt tplelm} as defined in the file {\tt tplelm.ds}.
This parse tree will then be evaluated to generate output.
Variable references, functions and numerical expressions are {\em not}
parsed at this moment, thereby simplifying the parse tree representation,
and allowing the use of a hand-written parser.
(The use of two {\tt yacc} parsers in the same program would have
caused considerable problems.)
\par
The parsing is done by the function {\tt readtemplate()}.
It reads lines from the input file up to and including the first
unbalanced end command ({\tt .endforeach}, {\tt .endwhile}, etc.)
or until end of file.
Commands that have an associated end command ({\tt .foreach},
{\tt .while}, etc.) are parsed by a recursive call to {\tt readtemplate()}.
\subsection{output generation}
Output generation is done by the function {\tt dotrans()}.
Given a list of parsed line commands (instances of type {\tt tplelm}),
it executes these commands.
During execution it may invoke itself recursively to handle
the body of block commands like {\tt .if} and {\tt .while}.
Plain lines are interpreted as a command to write a line to the
output file.
\par
Before each command is executed its parameter line (or for
plain lines the entire line) is evaluated by the function {\tt alevalto()}.
The function {\tt alevalto()} evaluates the following classes of
expressions:
\begin{itemize}
\item Variable references. These are looked up in the variable table 
      by the function {\tt getvar()} and copied into the output string.

\item Numerical expressions. These are handled by {\tt evalexpr()}.

\item Function invocations. These are handled by {\tt evalfn()}.
\end{itemize}
The working of {\tt alevalto()} can be traced by setting the variable
{\tt sevaltr} to {\tt TRUE}.
This can be done through the command line option {\tt -de}.
\subsubsection{variable handling}
Variables are handled by the functions in the file {\tt tmvar.c}.
They are set by a call to {\tt setvar()},
and looked up by the function {\tt getvar()}.
Since it must be guaranteed that the evaluation of a {\tt .include} file
will not affect the variables of the invoking template, separate contexts
are maintained for each {\tt .include} file.
A context is created by the function {\tt newvarctx()},
and is destroyed by the function {\tt flushvar()}.
The function {\tt setvar()} will place the new variable value in the topmost
context, so that the variable value will vanish when the current
{\tt .include} file is terminated.
The function {\tt getvar()} will search the contexts from the topmost
context downward, and will take the first variable value it finds.
\par
It is possible to trace the most important actions
on the variable table by setting the variable {\tt vartr} to {\tt TRUE}.
This can be done through the command line option {\tt -dv}.
\subsubsection{function evaluation}
The function {\tt evalfn()} evaluates a function as follows:
\begin{enumerate}
\item Evaluate the given string up to the next unbalanced `\verb!}!'
      by a call to {\tt alevalto()}.
      This will result in a string containing the function name and a list of
      parameters.

\item Divide the evaluated string into {\em words}. A word is a
      string of non-blanks or a string surrounded by \verb!""!.
      This division is done by the function {\tt chopstring()}.

\item Interpret the first word as the function name, and the
      remaining words as parameters.
      Look up the function in the table of functions {\tt fntab[]},
      and execute the found function. The parameters are passed
      to the function as a {\tt string\_list}. The function
      will return a {\tt string}.
\end{enumerate}
Many functions will construct a {\tt string\_list},
and they will use the function {\tt flatstrings()} to construct
a flat string from that {\tt string\_list()}.
Others will return a boolean by using the function {\tt newboolstr()},
or an integer by using the function {\tt newintstr()}.
\par
It is possible to trace the function evaluations
by setting the variable {\tt fntr} to {\tt TRUE}.
This can be done through the command line option {\tt -df}.
\section{Tm language support}
The code generated by the language templates of {\Tm} is documented
in the main part of this manual.
Therefore, only the non-obvious parts of the templates themselves
must be discussed.
\subsection{commonly used tricks in templates}
Tm is not exactly one of the most elegant programming languages,
and it is sometimes necessary to resort to obscure tricks to get the
required results.
The most common tricks are explained in this section.
\begin{verbatim}
.if ${index <word> <list>}
\end{verbatim}
See if \verb!<word>! occurs in \verb!<list>!.
\begin{verbatim}
.if ${len <list>}
\end{verbatim}
See if \verb!<list>! contains anything.
\begin{verbatim}
.if ${len ${telmlist <type>}}
\end{verbatim}
See if \verb!<type>! is a tuple type.
This works because constructor types will have an empty tuple
element list.
\begin{verbatim}
.if ${len ${conslist <type>}}
\end{verbatim}
See if \verb!<type>! is a constructor type.
This works because tuple types will have an empty constructor list.
\subsection{handling of {\tt wantdefs}}
All language templates use
a variable {\tt wantdefs} to determine which code must be generated.
For the handling of this variable all language templates use a copy of
a general deduction template that is adapted to the specific language
code.
Unfortunately a {\em copy} of the deduction template is necessary,
since the separation of the template in a language-dependent part and
language-independent part is difficult.

The deduction is done as follows:
First, all variables \verb!want_<function>! and \verb!want_<function>_list!
will be set to the list of types for which \verb!<function>! code
is requested.
For example, if {\tt wantdefs} contains \verb!app_coord_list! and
\verb!rev_plot!, the variable \verb!want_app_list! will contain
{\tt coord}, and the variable \verb!want_rev! will contain \verb!plot!.
For obvious reasons the \verb!<function>! should be known to the template.
\par
After all \verb!want_<function>! variables have been set, the variables
\verb!need_<function>! are set to the types for which code is necessary.
A needed function is
\begin{enumerate}
\item A wanted function.
\item A function invoked by a needed function.
\end{enumerate}
\par
Finally, the user may have specified that certain functions must not be
generated.
This is enforced by explicitly removing all those function from the
\verb!need_<function>! and \verb!want_<function>! lists. 
