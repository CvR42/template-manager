\documentclass{article}
\usepackage{a4wide}
\usepackage{makeidx}
\usepackage{verbatim}
\makeindex
\newcommand{\Pascal}{\sf Pascal}
\newcommand{\Tm}{\sf Tm}
\newenvironment{listing}{\small\begin{flushleft}}{\end{flushleft}}
\newenvironment{desc}{\nopagebreak\vspace{-\bigskipamount}\vspace{-\parskip}\begin{list}{}{\setlength{\topsep}{0pt}\setlength{\rightmargin}{0pt}}\item[]}{\end{list}}

% Description table.
% Width of description column in tabular environments.
\newlength{\descwidth}
\setlength{\descwidth}{\textwidth}
\addtolength{\descwidth}{-3.4cm}
\newenvironment{desctab}{\begin{tabular*}{\textwidth}{l@{\extracolsep{\fill}}p{\descwidth}}}{\end{tabular*}}
\author{C. van Reeuwijk}
\title{Tm Pascal Template Version 1.0 User's manual}
\begin{document}
\maketitle
\section{Introduction}
\begin{figure}[h]
\verbatiminput{plot.ds}
\caption{\label{f.ds}An example of a data structure description file.}
\end{figure}
This section provides the necessary information to use the {\Pascal}
templates of {\Tm}.
The information is split in two parts: in section \ref{s.pasquickintro}
a `cookbook' description of the use of the templates is given.
In the remaining sections a detailed description of the templates is given.
\par
The definitions are described using a {\Pascal} type specification,
but without the body.
\section{Usage}
\label{s.pasquickintro}
You can use the following steps to obtain {\Pascal} code from {\Tm}.
The steps are illustrated by an example.
\begin{enumerate}
\item
Design the structures for your problem,
and encode it in a structure description file.
For the example it is assumed that the file {\tt plot.ds} contains the
data structures of Fig.~\ref{f.ds}.
\item
Create a configuration file that sets the following {\Tm} variables:
\begin{itemize}
\item
The variable {\tt basename}:
a general name for the generated code.
\item
The variable {\tt wantdefs}: the names of the definitions that you
will use in your program.
If these definitions require other definitions for types defined in
the data structure definition file,
this will be deduced, and they will be generated.
For library and support functions this will {\em not} be deduced,
and you must add the names of these functions to {\tt wantdefs}.
\item
The variable {\tt notwantdefs}:
in the rare case that {\Tm} deduces that a definition must be generated
while this is not what you want,
this definition can be appended to the list of variable {\tt notwantdefs}.
\end{itemize}
For the running example a file {\tt pasconf.t} is used with the
following contents:
\begin{listing}
\verbatiminput{pasconf.t}
\end{listing}
\item
Create a {\Tm} skeleton file containing the required {\Pascal} environment.
This file should at least contain
\begin{itemize}
\item
An {\tt .insert} of the configuration file, in this example
{\tt pasconf.t}.
\item
An {\tt .include} of the necessary template files (see
section \ref{s.templates}).
\item
An invocation, early in the program, of {\tt Init<basename>}.
\end{itemize}
The file will also contain other stuff,
like definitions for primitive types.
If your {\Pascal} does not support separate compilation,
the file must also contain all other code.
\par
For the example the file is:
\begin{listing}
\verbatiminput{pasdemo.pt}
\end{listing}
\item
Add a make rule to your makefile to generate the code:
\begin{verbatim}
pasdemo.p : plot.ds pasdemo.pt pasconf.t
        tm plot.ds pasdemo.pt > pasdemo.p
\end{verbatim}
\end{enumerate}
\par
The file {\tt pasdemo.p} that is generated from our
example configuration is listed in appendix \ref{s.pasdemo}.
\section{The Pascal templates}
\label{s.templates}
\subsection{General}
In the design of the {\Pascal} templates it has been tried to make
them as general as possible.
However, the original {\Pascal} definition is too restricted for
easy code generation,
so that a number of assumptions had to be made.
These assumptions are:
\index{assumptions!Pascal}
\begin{enumerate}
\item
The {\Pascal} compiler distinguishes upper case and lower case characters
in symbols.
That is,
{\tt ZWOING} is different from {\tt zwoing},
and both are different from {\tt ZwoInG}.
\item
There is no (or a large) upper bound to the number of significant characters
in symbol names.
At least the characters of the type, constructor and element names
and 6 additional characters must be significant.
\item
The following standard functions and procedures are available.
\begin{verbatim}
write( f, e, .. e )
read( f, e )
eof( f )
eoln( f )
new( p, tag )
dispose( p, tag )
\end{verbatim}
\item
The type of the file handles for {\tt read} and {\tt write} is {\tt text}.
\end{enumerate}
\par
In all record types generated by these templates a {\tt next} field is
included that is used to create linked lists of the records.
Therefore, the type of a single element and a list of these elements is the
same.
For clarity
different type names are introduced for single elements and lists.
\par
Due to the strict syntax of {\Pascal},
the template must be split up in a number of parts,
one for the {\tt var}, {\tt type} and code sections.
This is also true for the code library.
Therefore,
the following template files are provided:
\begin{flushleft}
\begin{tabular}{lll}
file name & section & purpose \\
\hline
pascode.pt & (code) & Code template. \\
pascode.ht & (code) & {\tt external} declaration template. \\
paslib.pt & (code) & Library of functions. \\
paslib.ht & (code) & {\tt external} declaration of library functions. \\
pastype.pt & {\tt type} & Type declaration template. \\
pasvar.pt & {\tt var} & Variable declaration template. \\
pasgvar.pt & {\tt var} & General variable declarations. \\
\end{tabular}
\end{flushleft}
\par
The files {\tt pascode.ht} and {\tt paslib.ht} are used for
separate compilation,
see section \ref{s.sepcomp}.
\subsection{Initialization}
Before any other {\Tm} generated code is used the procedure
{\tt Init<basename>} must be invoked.
\begin{verbatim}
procedure Init<basename>;
\end{verbatim}
\begin{desc}
\index{Init<basename>@{\tt Init<basename>}}
Do necessary initializations for generated {\Tm} code.
\end{desc}
\subsection{Records}
The data is represented using the following {\tt type} definitions:
\begin{verbatim}
<type> = ^Rec<type>;
<type>list = <type>;
\end{verbatim}
\begin{desc}
\index{records|(}
First, all types and type lists are defined as pointers to a certain
record.
This indirect way is used to prevent problems with mutually recursive
types, since {\Pascal} does not mind the introduction of pointers to an
(temporarily) unknown record,
but it {\em does} mind references to unknown types.
For clarity
different type names are introduced for lists and single elements,
even though they are equivalent.
\end{desc}
\begin{verbatim}
Rec<type> = record
    next: <type>list;
    <elmname>: <elmtype>;
    :
    <elmname>: <elmtype>;
end;
\end{verbatim}
\begin{desc}
\index{tuple}
The representation of tuple types.
The {\tt next} field is used to create linked lists of {\tt <type>} elements.
\end{desc}
\begin{verbatim}
Alltags<type> = ( Tag<cons>, ... Tag<cons> );

Rec<type> = record
    next: <type>list;
    case tag: Alltags<type> of
        Tag<cons> :(
            <elmname>: <elmtype>;
            :
            <elmname>: <elmtype>;
        );
    end
end;
\end{verbatim}
\begin{desc}
\index{constructor}
The representation of constructor types.
The {\tt next} field is used to create linked lists of {\tt <type>} elements.
The possible constructors for the type are recognized by the contents of
the {\tt tag} field,
which contains a value of the enumerated type {\tt Alltags<type>}.
For each constructor of a type a variant is defined.
\index{records|)}
\end{desc}
\subsection{Allocation and freeing}
These procedures handle allocation and freeing of instances of the constructors.
\begin{verbatim}
procedure New<cons>(
    e1:<elmtype>;
    :
    en:<elmtype>;
    var n:<type>
);
procedure New<type>(
    e1:<elmtype>;
    :
    en:<elmtype>;
    var n:<type>
);
\end{verbatim}
\begin{desc}
\index{New<cons>@\verb+New<cons>()+}
\index{New<type>@\verb+New<type>()+}
Allocate space for a new of a constructor or tuple record,
and set each of the elements to the value of the given parameter
for that element.
Set the first parameter ({\tt n}) to the new record.
The {\tt next} field is set to {\tt nil}.
For constructors the {\tt tag} field is set to {\tt Tag<cons>}.
To request the generation of all {\tt New<cons>} functions for a certain
constructor type,
{\tt New<type>} must be added to {\tt wantdefs},
see section \ref{s.pasconfig} for an explanation of the use of {\tt wantdefs}.
\end{desc}
\begin{verbatim}
procedure Free<type>( var e: <type> );
procedure Free<type>list( var e: <type>list );
\end{verbatim}
\begin{desc}
\index{Free<type>@\verb+Free<type>()+}
\index{Free<type>list@\verb+Free<type>list()+}
Free an instance of {\tt <type>} or {\tt <type>list}.
The parameter {\tt e} will be set to {\tt nil}.
\end{desc}
\begin{verbatim}
procedure Rfre<type>( var e: <type> );
procedure Rfre<type>list( var e: <type>list );
\end{verbatim}
\begin{desc}
\index{Rfre<type>@\verb+Rfre<type>()+}
\index{Rfre<type>list@\verb+Rfre<type>list()+}
Recursively free an instance of {\tt <type>} or {\tt <type>list}
and all elements in it.
The parameter {\tt e} will be set to {\tt nil}.
\end{desc}
\begin{verbatim}
procedure Stat<basename>( var f: text );
\end{verbatim}
\begin{desc}
\index{Stat<basename>@\verb+Stat<basename>()+}
Write statistics of allocation and freeing to file {\tt f}.
Note that the code to collect statistics is only generated when the
generation of {\tt Stat<basename>} has been requested.
\end{desc}
\subsection{Appending and concatenation}
These functions handle appending (adding single elements at the end of the list)
and concatenation (adding a list at the end of an other list).
Since all single elements have their {\tt next} field set to {\tt nil}
by the {\tt New<cons>} or {\tt New<type>} function,
both classes of functions actually use the same code.
\begin{verbatim}
function App<type>( var l: <type>list; e: <type> ): <typelist>;
\end{verbatim}
\begin{desc}
\index{App<type>@\verb+App<type>()+}
Append element {\tt e} after list {\tt l},
and return the new list.
Remaining copies to the parameters {\tt l} and {\tt e} are still valid,
but are `owned' by the newly constructed list.
If {\tt l} or {\tt e} is {\tt nil}, the other parameter is returned.
\end{desc}
\subsection{Recursive copying}
These functions handle recursive copying of instances of types
and lists of types.
New instances are allocated for types that must be allocated.
\begin{verbatim}
function Copy<type>( <type> e ): <type>;
function Copy<type>list( <type>list e ): <type>list;
\end{verbatim}
\begin{desc}
\index{Copy<type>@\verb+Copy<type>()+}
\index{Copy<type>list@\verb+Copy<type>list()+}
Recursively copy instance {\tt e} of type {\tt <type>} or
{\tt <type>list}.
\end{desc}
\subsection{Input and output}
These functions handle reading and writing of a textual description of the
data structures.
They assume the existence of the following functions:
\index{assumptions!Pascal}
\begin{flushleft}
\begin{tabular}{ll}
name & purpose \\
\hline
{\tt tmgetc} &  Read next char of a text file. \\
{\tt tmreadspc} & Skip spaces and comment. \\
{\tt tmneedc} & Expect given char in file. \\
{\tt tmreadobrac} & Count open brackets. \\
{\tt tmreadcbrac} & Balance open brackets. \\
\end{tabular}
\end{flushleft}
See section \ref{s.paslib} for a detailed description.
\par
The {\tt Read<type>}, {\tt Read<type>list} and supporting routines
assume the existence of a few variables:
\begin{flushleft}
\begin{desctab}
{\tt tmcurchar}
&
This variable must contain the first character to use for all read
functions.
All read functions can assume that it is filled on entry,
and must ensure that it is filled on exit.
\par
This implies that before the top level {\tt Read<type>} function is used,
the variable must be filled with a call to {\tt tmgetc}
(see section \ref{s.paslib}).
\\
{\tt tmeolnchar}
&
Special char for the eoln condition as used in {\Pascal}.
\\
{\tt tmeofchar}
&
Special char for the eof condition as used in {\Pascal}.
\end{desctab}
\end{flushleft}
\par
The variables {\tt tmeolnchar} and {\tt tmeofchar} are
set to their value in the procedure {\tt Init<basename>}.
\begin{verbatim}
function Read<type>( var f, rf: text; var p: <type> );
function Read<type>list( var f, rf: text; var p: <type>list );
\end{verbatim}
\begin{desc}
\index{Read<type>@\verb+Read<type>()+}
\index{Read<type>list@\verb+Read<type>list()+}
Read an instance of record {\tt <type>} or {\tt <type>list} from
file {\tt f},
allocate memory to hold the data that is read,
and set {\tt p} to the new data.
If no error occurs, a value {\tt false} is returned.
If an error occurs during reading,
a value {\tt true} is returned, and an error message is written
to the file {\tt rf}.
For all the data that has been read before the error, memory is allocated,
but the allocated records may contain garbage values for the record
elements that could not be read due to the error.
\end{desc}
\begin{verbatim}
procedure Write<type>( var f: text; t: <type> );
procedure Write<type>list( var f: text, t: <type>list );
\end{verbatim}
\begin{desc}
\index{Write<type>@\verb+Write<type>()+}
\index{Write<type>list@\verb+Write<type>list()+}
Write an instance of record {\tt <type>} or {\tt <type>list}
to file {\tt f} in the internal representation of {\Tm}.
\end{desc}
\subsection{Comparison}
These functions handle recursive comparison of structures.
Given two data structures {\tt a} and {\tt b},
an integer ${\tt n}<0$ is returned if ${\tt a}<{\tt b}$,
0 if ${\tt a}={\tt b}$,
and an integer ${\tt n}>0$ if ${\tt a}>{\tt b}$,
\par
For comparison the following rules are applied:
\begin{itemize}
\item
Tuples are equal if all their elements are equal,
else the first differing element from the left determines the comparison.
\item
Constructors are ordered according to their order of definition in the
data structure file,
where the first constructor is the smallest.
Constructors are equal if all their elements are equal,
else the first differing element from the left determines the comparison.
\item
Lists are equal if all their elements are equal,
else the first differing element from the left determines the comparison,
or else the shortest list is the smallest.
\end{itemize}
\par
These functions are mainly intended for equality comparison,
and to impose `some' repeatable ordering on the data structures.
The ordering may be different from the desired ordering.
If an other comparison function is required for one data type,
the generation of the standard function can be suppressed by
using {\tt notwantdefs}, see section \ref{s.pasconfig}.
\begin{verbatim}
function Cmp<type>( a: <type>; b: <type> ): integer;
function Cmp<type>list( a: <type>list; b: <type>list ): integer;
\end{verbatim}
\begin{desc}
\index{Cmp<type>@\verb+Cmp<type>()+}
\index{Cmp<type>list@\verb+Cmp<type>list()+}
Compare data structures {\tt a} and {\tt b}, and return a code
according to the table listed previously.
\end{desc}
\section{Pascal code library}
\label{s.paslib}
The {\Pascal} code library provides definitions in
the same class as the generated definitions for a number of commonly used
primitive types.
It also contains low-level definitions that are required by the generated
definitions.
\begin{verbatim}
procedure tmgetc( var f: text );
\end{verbatim}
\begin{desc}
\index{tmgetc@\verb+tmgetc()+}
Read a character from file {\tt f} in the global variable {\tt tmcurchar}.
The eoln condition is converted to a special
{\tt tmeolnchar} character.
During eof {\tt tmeofchar} is put into {\tt tmcurchar}.
\end{desc}
\begin{verbatim}
procedure tmreadspc( var f: text );
\end{verbatim}
\begin{desc}
\index{tmreadspc@\verb+tmreadspc()+}
Skip all spaces, tabs, form feeds and comment in the input up to the
next non-white character.
A comment is started with a {\em single} {\tt |} and is terminated by a newline.
To remain compatible with the Miranda parser,
a file should always use {\tt ||} as comment start,
but to check this causes problems in parsing.
\end{desc}
\begin{verbatim}
function tmneedc( var f, rf: text; c: char ): boolean;
\end{verbatim}
\begin{desc}
\index{tmneedc@\verb+tmneedc()+}
After skipping spaces, tabs, form feeds and comment,
try to read character {\tt c} from file {\tt f}.
Return a value {\tt true} and write an error message to {\tt rf} if this
is not possible,
else return {\tt false}.
\end{desc}
\begin{verbatim}
function tmreadc( var f, rf: text; var c: char ): boolean;
\end{verbatim}
\begin{desc}
\index{tmreadc@\verb+tmreadc()+}
Read a char from file {\tt f} into {\tt c}.
Preceding blanks and comment are {\em not} skipped.
Backslash escape sequences are recognized and interpreted.
This function is used by {\tt Readchar},
and should be used by {\tt Readstring} if it is implemented.
\end{desc}
\begin{verbatim}
procedure tmreadobrac( var f: text; var n: integer );
function tmreadcbrac( var f, rf: text; n: integer ): boolean;
\end{verbatim}
\begin{desc}
\index{tmreadobrac@\verb+tmreadobrac()+}
\index{tmreadcbrac@\verb+tmreadcbrac()+}
Handle brackets around constructors.
{\tt tmreadobrac()} counts and sets parameter {\tt n} to the number
of open brackets (`{\tt (}') it encounters up to the first character
that is not white space, comment  or an open bracket.
{\tt tmreadcbrac()} tries to read {\tt n} close brackets (`{\tt )}'),
and will return {\tt true} and write an error message to {\tt rf} if this
is not possible,
or will return {\tt false} if it is successful.
\end{desc}
\begin{verbatim}
procedure tmwritec( var f: text; c: char );
\end{verbatim}
\begin{desc}
\index{tmwritec@\verb+tmwritec()+}
Write a char {\tt c} to file {\tt f}.
Backslash escape sequences are used when necessary.
This function is used by {\tt Writechar},
and should be used by {\tt Writestring} if it is implemented.
\end{desc}
\begin{verbatim}
function Readreal( var f, rf: text; var r: real ): boolean;
procedure Writereal( var f: text; r: real );
procedure Rfrereal( r: real );
function Cmpreal( a, b: real ): integer;
\end{verbatim}
\begin{desc}
\index{Readreal@\verb+Readreal()+}
\index{Writereal@\verb+Writereal()+}
\index{Rfrereal@\verb+Rfrereal()+}
\index{Cmpreal@\verb+Cmpreal()+}
Module functions for type `real'.
\end{desc}
\begin{verbatim}
int Readinteger( var f, rf: text; var i: integer ): boolean;
procedure Writeinteger( var f: text; i: integer );
procedure Rfreinteger( r: integer );
function Cmpinteger( a, b: integer ): integer;
\end{verbatim}
\begin{desc}
\index{Readinteger@\verb+Readinteger()+}
\index{Writeinteger@\verb+Writeinteger()+}
\index{Rfreinteger@\verb+Rfreinteger()+}
\index{Cmpinteger@\verb+Cmpinteger()+}
Module functions for type `integer'.
\end{desc}
\begin{verbatim}
function Readboolean( var f, rf: text; var b: boolean ): boolean;
procedure Writeboolean( var f: text; b: boolean );
procedure Rfreboolean( b: boolean );
function Cmpboolean( a, b: boolean ): integer;
\end{verbatim}
\begin{desc}
\index{Readboolean@\verb+Readboolean()+}
\index{Writeboolean@\verb+Writeboolean()+}
\index{Rfreboolean@\verb+Rfreboolean()+}
\index{Cmpboolean@\verb+Cmpboolean()+}
Module functions for type `boolean'.
\end{desc}
\begin{verbatim}
function Readchar( var f, rf: text; var c: char ): boolean;
procedure Writechar( var f: text; c: char );
procedure Rfrechar( c: char );
function Cmpchar( a, b: char ): integer;
\end{verbatim}
\begin{desc}
\index{Readchar@\verb+Readchar()+}
\index{Writechar@\verb+Writechar()+}
\index{Rfrechar@\verb+Rfrechar()+}
\index{Cmpchar@\verb+Cmpchar()+}
Module functions for type `char'.
\end{desc}
\section{Tm configuration variables}
\label{s.pasconfig}
The templates use a few {\Tm} variables to modify the contents
of the generated code.
Unless stated otherwise,
it is not necessary to set them;
a reasonable default will be chosen.
\par
\begin{desctab}
{\tt basename}
&
This variable is used to generate the names of 
definitions that are generated only once
(e.g. initialization and statistics procedures).
This variable
{\em must}
be set.
\\
{\tt wantdefs}\index{wantdefs@{\tt wantdefs}}
&
If set,
this variable contains the names of the type and function definitions that
must be generated.
If these functions require the definition of other functions,
the necessary functions will be generated,
but will be declared {\tt static}.
If {\tt alldefs} is set all possible definitions are generated.
\par
There is one exception:
to request the generation of {\tt New<cons>} functions for a certain
constructor type {\tt <type>},
{\tt New<type>} must be added to {\tt wantdefs}.
\\
{\tt notwantdefs}\index{notwantdefs@{\tt notwantdefs}}
&
If set,
this variable contains the names of the type and function definitions for
which under all conditions {\tt no} code must be generated.
\\
{\tt alldefs}\index{alldefs@{\tt alldefs}}
&
If set,
this variable indicates that all possible type and function definitions must
be generated.
\end{desctab}
\par
At least one of the variables {\tt wantdefs} and {\tt alldefs} must be set.
\par
The the variable {\tt wantdefs} should contain the names of all definitions
that must be generated.
These definitions may require other definitions,
and for for the types defined in the data structure file
these requirements will be deduced,
and the necessary code will be generated.
However,
the need for support functions (e.g. {\tt tmgetc}) and functions for standard
primitive types (e.g. {\tt Readreal}) is {\em not} deduced,
and the generation of these functions must be requested explicitly.
\section{Separate compilation}
\label{s.sepcomp}
For {\Pascal} compilers that support separate compilation some special
template files are available: {\tt pascode.ht} and {\tt paslib.ht}.
These files contain {\tt external} declarations for the code in {\tt pascode.pt}
and {\tt paslib.pt} respectively.
Only for the definitions that have been requested using {\tt wantdefs}
declarations will be generated.
For example, an external declaration for {\tt tmgetc} will look like:
\begin{verbatim}
procedure tmgetc( var f: text ); external;
\end{verbatim}
Inclusion of these declarations in other parts of the program must be
arranged by the the programmer.
The variables generated by {\tt pasvar.pt} are only necessary
for the code generated by {\tt pascode.pt},
so that they do not have to be made visible to other files.
Provided that all {\tt Read<type>} functions for primitive
types are in the same file as the generated code,
the variables of {\tt pasgvar.pt} do not have to be make visible either.
\printindex
\appendix
\section{Listing of the file `pasdemo.p'}
\label{s.pasdemo}
\begin{listing}
\verbatiminput{pasdemo.p}
\end{listing}
\end{document}
