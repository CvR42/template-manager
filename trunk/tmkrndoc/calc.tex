\chapter{An example project: expression optimization}
\label{s.calc}
In this chapter we will present three small but complete programs.
One parses a simple language, and prints it out in the standard Tm
representation. A second program reads in this representation, replaces
constant expressions with a single constant, and writes it out again.
A third one also reads this representation, replaces references to
known variables with their value, and writes it out again.
The third program not only uses external functions generated by a
standard Tm template, but is for a significant part generated from
a tree walker template.

The parser reads a series of assignments, such as:
\begin{showfile}
\verbatimtabinput{test.calc}
\end{showfile}
and writes out the parse tree of the input file in Tm format.
The other programs reads the parse tree in Tm format, transform it,
and write out the transformed parse tree.

The files shown in this appendix are available as a separate package,
called \verb'tmdemo'. See the Tm FTP site.

\section{The parser}
\label{s.calcparser}
The assignment commands are represented with the following data structures:
\begin{showfile}
\verbatimtabinput{calc.ds}
\end{showfile}

To read in the commands, lexical analysis and parsing must be done.
Lexical analysis is done with a lexical analyzer generated by
\texttt{lex}. It is specified as follows:
\begin{showfile}
\verbatimtabinput{calclex.l}
\end{showfile}

Parsing is done in a \texttt{yacc} file
\begin{showfile}
\verbatimtabinput{calcparse.y}
\end{showfile}

This file also contains the \verb'main()' function, which invokes the
parser and prints the result to a Tm textual representation using the
function \verb'print_command_list()'. The actions of the \texttt{yacc}
grammar also contain functions generated by Tm to construct intermediate 
parts of the parse tree, for example the \verb'new_command()' function.

\begin{sloppypar}
Finally, the file contains the functions \verb'rfre_command_list()',
\verb'get_balance_calc()' and \verb'stat_calc()'. The first recursively
deallocates all elements in the constructed command list, and the latter
two are used to report any imbalance in the number of allocations and
deallocations. They are not strictly necessary, but in practice have
proven to be invaluable for reliable dynamic memory management.
\end{sloppypar}
\par
Given an input file:
\begin{showfile}
\verbatimtabinput{test.calc}
\end{showfile}
the parser will produce the following output:
\begin{showfile}
\verbatimtabinput{oktest.clc}
\end{showfile}
\section{The optimizer}
The optimizer is a very simple program that reads a command list
in Tm format, evaluates all constant expressions, and writes back the
simplified command list in Tm format.
\begin{showfile}
\verbatimtabinput{calcopt.c}
\end{showfile}
\begin{sloppypar}
Reading and writing is done with the functions
\verb'fscan_command_list()' and \verb'print_command_list()'
respectively. Inbetween, a simple recursive tree walker visits all nodes
of all expression trees, and replaces all nodes containing constant
expressions with the result of evaluation.
\end{sloppypar}

Given the output from the parser shown above, the optimizer will produce
the following output:
\begin{showfile}
\verbatimtabinput{okopt.clc}
\end{showfile}
Note that the expression $c+3+4$ is not simplified, because the parser
interprets this as $(c+3)+4$, which does not contain a constant
expression. A real-life optimizer will probably have to do better
than this.
\section{The substitution engine}
The substitution engine is a small program that reads a command list
in Tm format, and substitutes all references to known variables with
their value.
It is implemented using the tree walker template, see Section~\ref{s.treewalk}.
\begin{showfile}
\verbatiminput{subst.ct}
\end{showfile}
The input and output is done in the same way as in the optimizer 
described in the previous section. The substitution is implemented as
a tree walker generated by the \verb'tmcwalk.t' template. It has
two actions: function \verb'subst_ExprSymbol_action' searches the list
of known definitions for the symbol of the expression, and replaces
it with the value of that symbol. Function \verb'subst_command_action'
updates the list of known symbols.
\par
If we feed the output from the parser shown above to the substitution
engine, and apply the optimizer engine above to the output, the following
output is produced:
\begin{showfile}
\verbatimtabinput{oksubst.clc}
\end{showfile}
\par
For people that are curious about the generated tree walker code, the
result of
\begin{verbatim}
tm calc.ds subst.ct
\end{verbatim}
is the following file:
\begin{showfile}
\verbatimtabinput{subst.c}
\end{showfile}
\section{Generated functions}
To use Tm to generate code, it is necessary to provide a
number of files. The data structure definitions were already shown above.
Apart from that, the functions that must be generated are listed in a
separate file:
\begin{showfile}
\verbatimtabinput{calcconf.t}
\end{showfile}
Since the same source file is used for both the parser and the
optimizer, this file lists all functions that are required by either.
Notice the trick to generate all \verb'new_<t>' functions for subclasses
of \texttt{expr}.

Next, two small files must be provided that include the configuration
file shown above, and invoke a standard template. These files will be
expanded into a \verb'.c' and a \verb'.h' file. The template for the
\verb'.c' file must also contain a \verb'#include' for the header of the
standard Tm C library (called \verb'tmc.h'), and the generated \verb'.h'
file. This is shown in the template files listed here:

For the example the two template files are:
\begin{showfile}
\verbatimtabinput{calc.ht}
\end{showfile}
and
\begin{showfile}
\verbatimtabinput{calc.ct}
\end{showfile}
In general, the header files may also contain other stuff,
such as functions for primitive types.

Finally, you can add rules to your makefile to generate the code:
\begin{showfile}
\begin{verbatim}
calc.c: calc.ds calc.ct calcconf.t
        tm calc.ds calc.ct > calc.c

calc.h: calc.ds calc.ht calcconf.t
        tm calc.ds calc.ht > calc.h
\end{verbatim}
\end{showfile}
This will result in a header file \verb'calc.h':
\begin{showfile}
\verbatimtabinput{calc.h}
\end{showfile}
and a C source file \verb'calc.c':
\begin{showfile}
\verbatimtabinput{calc.c}
\end{showfile}
